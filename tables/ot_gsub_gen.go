package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from ot_gsub_src.go. DO NOT EDIT

func ParseAlternateSet(src []byte) (AlternateSet, int, error) {
	var item AlternateSet
	n := 0
	{
		if L := len(src); L < 2 {
			return AlternateSet{}, 0, fmt.Errorf("reading AlternateSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return AlternateSet{}, 0, fmt.Errorf("reading AlternateSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.AlternateGlyphIDs = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.AlternateGlyphIDs {
			item.AlternateGlyphIDs[i] = GlyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseAlternateSubstitution(src []byte) (AlternateSubstitution, int, error) {
	var item AlternateSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.CoverageOffset, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.AlternateSets = make([]AlternateSet, arrayLength) // allocation guarded by the previous check
		for i := range item.AlternateSets {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.AlternateSets[i], _, err = ParseAlternateSet(src[offset:])
			if err != nil {
				return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseChainedClassSequenceRule(src []byte) (ChainedClassSequenceRule, int, error) {
	var item ChainedClassSequenceRule
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.BacktrackSequence = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.BacktrackSequence {
			item.BacktrackSequence[i] = binary.BigEndian.Uint16(src[2+i*2:])
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		item.inputGlyphCount = binary.BigEndian.Uint16(src[n:])
		n += 2
	}
	{
		arrayLength := int(item.inputGlyphCount - 1)

		if L := len(src); L < n+arrayLength*2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.InputSequence = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.InputSequence {
			item.InputSequence[i] = binary.BigEndian.Uint16(src[n+i*2:])
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.LookaheadGlyphCount = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.LookaheadGlyphCount {
			item.LookaheadGlyphCount[i] = binary.BigEndian.Uint16(src[n+i*2:])
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*4 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.SeqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.SeqLookupRecords {
			item.SeqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseChainedClassSequenceRuleSet(src []byte) (ChainedClassSequenceRuleSet, int, error) {
	var item ChainedClassSequenceRuleSet
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedClassSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedClassSequenceRuleSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ChainedClassSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedClassSequenceRuleSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.ChainedClassSeqRules = make([]ChainedClassSequenceRule, arrayLength) // allocation guarded by the previous check
		for i := range item.ChainedClassSeqRules {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedClassSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedClassSequenceRuleSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.ChainedClassSeqRules[i], _, err = ParseChainedClassSequenceRule(src[offset:])
			if err != nil {
				return ChainedClassSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedClassSequenceRuleSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs1(src []byte) (ChainedContextualSubs1, int, error) {
	var item ChainedContextualSubs1
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.ChainedSeqRuleSet = make([]ChainedSequenceRuleSet, arrayLength) // allocation guarded by the previous check
		for i := range item.ChainedSeqRuleSet {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.ChainedSeqRuleSet[i], _, err = ParseChainedSequenceRuleSet(src[offset:])
			if err != nil {
				return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs2(src []byte) (ChainedContextualSubs2, int, error) {
	var item ChainedContextualSubs2
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[4:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.BacktrackClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[6:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.InputClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 10 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[8:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.LookaheadClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 12 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[10:]))
		n += 2

		if L := len(src); L < 12+arrayLength*2 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", 12+arrayLength*2, L)
		}

		item.ChainedClassSeqRuleSet = make([]ChainedClassSequenceRuleSet, arrayLength) // allocation guarded by the previous check
		for i := range item.ChainedClassSeqRuleSet {
			offset := int(binary.BigEndian.Uint16(src[12+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.ChainedClassSeqRuleSet[i], _, err = ParseChainedClassSequenceRuleSet(src[offset:])
			if err != nil {
				return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs3(src []byte) (ChainedContextualSubs3, int, error) {
	var item ChainedContextualSubs3
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.BacktrackCoverages = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.BacktrackCoverages {
			offset := int(binary.BigEndian.Uint16(src[4+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.BacktrackCoverages[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.InputCoverages = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.InputCoverages {
			offset := int(binary.BigEndian.Uint16(src[n+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.InputCoverages[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.LookaheadCoverages = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.LookaheadCoverages {
			offset := int(binary.BigEndian.Uint16(src[n+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.LookaheadCoverages[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*4 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.SeqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.SeqLookupRecords {
			item.SeqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseChainedContextualSubstitution(src []byte) (ChainedContextualSubstitution, int, error) {
	var item ChainedContextualSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedContextualSubstitution{}, 0, fmt.Errorf("reading ChainedContextualSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = chainedContextualSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case chainedContextualSubsVersion1:
			item.Data, read, err = ParseChainedContextualSubs1(src[:])
		case chainedContextualSubsVersion2:
			item.Data, read, err = ParseChainedContextualSubs2(src[:])
		case chainedContextualSubsVersion3:
			item.Data, read, err = ParseChainedContextualSubs3(src[:])
		default:
			err = fmt.Errorf("unsupported ChainedContextualSubsVersion %d", item.format)
		}
		if err != nil {
			return ChainedContextualSubstitution{}, 0, fmt.Errorf("reading ChainedContextualSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseChainedSequenceRule(src []byte) (ChainedSequenceRule, int, error) {
	var item ChainedSequenceRule
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.BacktrackSequence = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.BacktrackSequence {
			item.BacktrackSequence[i] = GlyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		item.inputGlyphCount = binary.BigEndian.Uint16(src[n:])
		n += 2
	}
	{
		arrayLength := int(item.inputGlyphCount - 1)

		if L := len(src); L < n+arrayLength*2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.InputSequence = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.InputSequence {
			item.InputSequence[i] = GlyphID(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		item.LookaheadSequence = GlyphID(binary.BigEndian.Uint16(src[n:]))
		n += 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*4 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.SeqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.SeqLookupRecords {
			item.SeqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseChainedSequenceRuleSet(src []byte) (ChainedSequenceRuleSet, int, error) {
	var item ChainedSequenceRuleSet
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedSequenceRuleSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ChainedSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedSequenceRuleSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.ChainedSeqRules = make([]ChainedSequenceRule, arrayLength) // allocation guarded by the previous check
		for i := range item.ChainedSeqRules {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedSequenceRuleSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.ChainedSeqRules[i], _, err = ParseChainedSequenceRule(src[offset:])
			if err != nil {
				return ChainedSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedSequenceRuleSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseClassDef(src []byte) (ClassDef, int, error) {
	var item ClassDef
	n := 0
	{
		if L := len(src); L < 2 {
			return ClassDef{}, 0, fmt.Errorf("reading ClassDef: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = classDefVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case classDefVersion1:
			item.data, read, err = parseClassDefData1(src[2:])
		case classDefVersion2:
			item.data, read, err = parseClassDefData2(src[2:])
		default:
			err = fmt.Errorf("unsupported classDefDataVersion %d", item.format)
		}
		if err != nil {
			return ClassDef{}, 0, fmt.Errorf("reading ClassDef: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseClassSequenceRule(src []byte) (ClassSequenceRule, int, error) {
	var item ClassSequenceRule
	n := 0
	{
		if L := len(src); L < 4 {
			return ClassSequenceRule{}, 0, fmt.Errorf("reading ClassSequenceRule: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.glyphCount = binary.BigEndian.Uint16(src[0:])
		item.seqLookupCount = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		arrayLength := int(item.glyphCount - 1)

		if L := len(src); L < 4+arrayLength*2 {
			return ClassSequenceRule{}, 0, fmt.Errorf("reading ClassSequenceRule: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.InputSequence = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.InputSequence {
			item.InputSequence[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLength * 2
	}
	{
		arrayLength := int(item.seqLookupCount)

		if L := len(src); L < n+arrayLength*4 {
			return ClassSequenceRule{}, 0, fmt.Errorf("reading ClassSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.SeqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.SeqLookupRecords {
			item.SeqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseClassSequenceRuleSet(src []byte) (ClassSequenceRuleSet, int, error) {
	var item ClassSequenceRuleSet
	n := 0
	{
		if L := len(src); L < 2 {
			return ClassSequenceRuleSet{}, 0, fmt.Errorf("reading ClassSequenceRuleSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ClassSequenceRuleSet{}, 0, fmt.Errorf("reading ClassSequenceRuleSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.ClassSeqRule = make([]ClassSequenceRule, arrayLength) // allocation guarded by the previous check
		for i := range item.ClassSeqRule {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ClassSequenceRuleSet{}, 0, fmt.Errorf("reading ClassSequenceRuleSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.ClassSeqRule[i], _, err = ParseClassSequenceRule(src[offset:])
			if err != nil {
				return ClassSequenceRuleSet{}, 0, fmt.Errorf("reading ClassSequenceRuleSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs1(src []byte) (ContextualSubs1, int, error) {
	var item ContextualSubs1
	n := 2
	{
		if L := len(src); L < 4 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.SeqRuleSet = make([]SequenceRuleSet, arrayLength) // allocation guarded by the previous check
		for i := range item.SeqRuleSet {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.SeqRuleSet[i], _, err = ParseSequenceRuleSet(src[offset:])
			if err != nil {
				return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs2(src []byte) (ContextualSubs2, int, error) {
	var item ContextualSubs2
	n := 2
	{
		if L := len(src); L < 4 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[4:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.ClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[6:]))
		n += 2

		if L := len(src); L < 8+arrayLength*2 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", 8+arrayLength*2, L)
		}

		item.ClassSeqRuleSet = make([]ClassSequenceRuleSet, arrayLength) // allocation guarded by the previous check
		for i := range item.ClassSeqRuleSet {
			offset := int(binary.BigEndian.Uint16(src[8+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.ClassSeqRuleSet[i], _, err = ParseClassSequenceRuleSet(src[offset:])
			if err != nil {
				return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs3(src []byte) (ContextualSubs3, int, error) {
	var item ContextualSubs3
	n := 2
	{
		if L := len(src); L < 6 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[5] // early bound checking
		item.glyphCount = binary.BigEndian.Uint16(src[2:])
		item.seqLookupCount = binary.BigEndian.Uint16(src[4:])
		n += 4
	}
	{
		arrayLength := int(item.glyphCount)

		if L := len(src); L < 6+arrayLength*2 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.CoverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.CoverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.CoverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		arrayLength := int(item.seqLookupCount)

		if L := len(src); L < n+arrayLength*4 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.SeqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.SeqLookupRecords {
			item.SeqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseContextualSubstitution(src []byte) (ContextualSubstitution, int, error) {
	var item ContextualSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ContextualSubstitution{}, 0, fmt.Errorf("reading ContextualSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = contextualSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case contextualSubsVersion1:
			item.Data, read, err = ParseContextualSubs1(src[:])
		case contextualSubsVersion2:
			item.Data, read, err = ParseContextualSubs2(src[:])
		case contextualSubsVersion3:
			item.Data, read, err = ParseContextualSubs3(src[:])
		default:
			err = fmt.Errorf("unsupported ContextualSubsVersion %d", item.format)
		}
		if err != nil {
			return ContextualSubstitution{}, 0, fmt.Errorf("reading ContextualSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseCoverage(src []byte) (Coverage, int, error) {
	var item Coverage
	n := 0
	{
		if L := len(src); L < 2 {
			return Coverage{}, 0, fmt.Errorf("reading Coverage: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = coverageVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case coverageVersion1:
			item.data, read, err = parseCoverageData1(src[2:])
		case coverageVersion2:
			item.data, read, err = parseCoverageData2(src[2:])
		default:
			err = fmt.Errorf("unsupported coverageDataVersion %d", item.format)
		}
		if err != nil {
			return Coverage{}, 0, fmt.Errorf("reading Coverage: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseExtensionSubstitution(src []byte) (ExtensionSubstitution, int, error) {
	var item ExtensionSubstitution
	n := 0
	{
		if L := len(src); L < 6 {
			return ExtensionSubstitution{}, 0, fmt.Errorf("reading ExtensionSubstitution: "+"EOF: expected length: 6, got %d", L)
		}
		_ = src[5] // early bound checking
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		item.ExtensionLookupType = binary.BigEndian.Uint16(src[2:])
		item.ExtensionOffset = Offset32(binary.BigEndian.Uint16(src[4:]))
		n += 6
	}
	{

		item.RawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseLigature(src []byte) (Ligature, int, error) {
	var item Ligature
	n := 0
	{
		if L := len(src); L < 4 {
			return Ligature{}, 0, fmt.Errorf("reading Ligature: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.LigatureGlyph = GlyphID(binary.BigEndian.Uint16(src[0:]))
		item.componentCount = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		arrayLength := int(item.componentCount - 1)

		if L := len(src); L < 4+arrayLength*2 {
			return Ligature{}, 0, fmt.Errorf("reading Ligature: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.ComponentGlyphIDs = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.ComponentGlyphIDs {
			item.ComponentGlyphIDs[i] = GlyphID(binary.BigEndian.Uint16(src[4+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseLigatureSet(src []byte) (LigatureSet, int, error) {
	var item LigatureSet
	n := 0
	{
		if L := len(src); L < 2 {
			return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.Ligatures = make([]Ligature, arrayLength) // allocation guarded by the previous check
		for i := range item.Ligatures {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.Ligatures[i], _, err = ParseLigature(src[offset:])
			if err != nil {
				return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseLigatureSubstitution(src []byte) (LigatureSubstitution, int, error) {
	var item LigatureSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.LigatureSets = make([]LigatureSet, arrayLength) // allocation guarded by the previous check
		for i := range item.LigatureSets {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.LigatureSets[i], _, err = ParseLigatureSet(src[offset:])
			if err != nil {
				return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseMultipleSubstitution(src []byte) (MultipleSubstitution, int, error) {
	var item MultipleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.CoverageOffset, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.Sequences = make([]Sequence, arrayLength) // allocation guarded by the previous check
		for i := range item.Sequences {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.Sequences[i], _, err = ParseSequence(src[offset:])
			if err != nil {
				return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseReverseChainSingleSubstitution(src []byte) (ReverseChainSingleSubstitution, int, error) {
	var item ReverseChainSingleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.BacktrackCoverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.BacktrackCoverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.BacktrackCoverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.LookaheadCoverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.LookaheadCoverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[n+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.LookaheadCoverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.SubstituteGlyphIDs = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.SubstituteGlyphIDs {
			item.SubstituteGlyphIDs[i] = GlyphID(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSequence(src []byte) (Sequence, int, error) {
	var item Sequence
	n := 0
	{
		if L := len(src); L < 2 {
			return Sequence{}, 0, fmt.Errorf("reading Sequence: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return Sequence{}, 0, fmt.Errorf("reading Sequence: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.SubstituteGlyphIDs = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.SubstituteGlyphIDs {
			item.SubstituteGlyphIDs[i] = GlyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSequenceLookupRecord(src []byte) (SequenceLookupRecord, int, error) {
	var item SequenceLookupRecord
	n := 0
	if L := len(src); L < 4 {
		return SequenceLookupRecord{}, 0, fmt.Errorf("reading SequenceLookupRecord: "+"EOF: expected length: 4, got %d", L)
	}
	item.mustParse(src)
	n += 4
	return item, n, nil
}

func ParseSequenceRule(src []byte) (SequenceRule, int, error) {
	var item SequenceRule
	n := 0
	{
		if L := len(src); L < 4 {
			return SequenceRule{}, 0, fmt.Errorf("reading SequenceRule: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.glyphCount = binary.BigEndian.Uint16(src[0:])
		item.seqLookupCount = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		arrayLength := int(item.glyphCount - 1)

		if L := len(src); L < 4+arrayLength*2 {
			return SequenceRule{}, 0, fmt.Errorf("reading SequenceRule: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.InputSequence = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.InputSequence {
			item.InputSequence[i] = GlyphID(binary.BigEndian.Uint16(src[4+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		arrayLength := int(item.seqLookupCount)

		if L := len(src); L < n+arrayLength*4 {
			return SequenceRule{}, 0, fmt.Errorf("reading SequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.SeqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.SeqLookupRecords {
			item.SeqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseSequenceRuleSet(src []byte) (SequenceRuleSet, int, error) {
	var item SequenceRuleSet
	n := 0
	{
		if L := len(src); L < 2 {
			return SequenceRuleSet{}, 0, fmt.Errorf("reading SequenceRuleSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return SequenceRuleSet{}, 0, fmt.Errorf("reading SequenceRuleSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.SeqRule = make([]SequenceRule, arrayLength) // allocation guarded by the previous check
		for i := range item.SeqRule {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return SequenceRuleSet{}, 0, fmt.Errorf("reading SequenceRuleSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.SeqRule[i], _, err = ParseSequenceRule(src[offset:])
			if err != nil {
				return SequenceRuleSet{}, 0, fmt.Errorf("reading SequenceRuleSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseSingleSubstData1(src []byte) (SingleSubstData1, int, error) {
	var item SingleSubstData1
	n := 2
	{
		if L := len(src); L < 4 {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: 2, got %d", L)
		}
		item.DeltaGlyphID = int16(binary.BigEndian.Uint16(src[4:]))
		n += 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseSingleSubstData2(src []byte) (SingleSubstData2, int, error) {
	var item SingleSubstData2
	n := 2
	{
		if L := len(src); L < 4 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.SubstituteGlyphIDs = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.SubstituteGlyphIDs {
			item.SubstituteGlyphIDs[i] = GlyphID(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSingleSubstitution(src []byte) (SingleSubstitution, int, error) {
	var item SingleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return SingleSubstitution{}, 0, fmt.Errorf("reading SingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = singleSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.substFormat {
		case singleSubsVersion1:
			item.Data, read, err = ParseSingleSubstData1(src[:])
		case singleSubsVersion2:
			item.Data, read, err = ParseSingleSubstData2(src[:])
		default:
			err = fmt.Errorf("unsupported SingleSubstDataVersion %d", item.substFormat)
		}
		if err != nil {
			return SingleSubstitution{}, 0, fmt.Errorf("reading SingleSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func (item *SequenceLookupRecord) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.SequenceIndex = binary.BigEndian.Uint16(src[0:])
	item.LookupListIndex = binary.BigEndian.Uint16(src[2:])
}

func (item *classRangeRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.StartGlyphID = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.EndGlyphID = GlyphID(binary.BigEndian.Uint16(src[2:]))
	item.Class = binary.BigEndian.Uint16(src[4:])
}

func parseClassDefData1(src []byte) (classDefData1, int, error) {
	var item classDefData1
	n := 0
	{
		if L := len(src); L < 2 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: 2, got %d", L)
		}
		item.StartGlyphID = GlyphID(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*2 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.ClassValueArray = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.ClassValueArray {
			item.ClassValueArray[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func parseClassDefData2(src []byte) (classDefData2, int, error) {
	var item classDefData2
	n := 0
	{
		if L := len(src); L < 2 {
			return classDefData2{}, 0, fmt.Errorf("reading classDefData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return classDefData2{}, 0, fmt.Errorf("reading classDefData2: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.ClassRangeRecords = make([]classRangeRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.ClassRangeRecords {
			item.ClassRangeRecords[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func parseCoverageData1(src []byte) (coverageData1, int, error) {
	var item coverageData1
	n := 0
	{
		if L := len(src); L < 2 {
			return coverageData1{}, 0, fmt.Errorf("reading coverageData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return coverageData1{}, 0, fmt.Errorf("reading coverageData1: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.Glyphs = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.Glyphs {
			item.Glyphs[i] = GlyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func parseCoverageData2(src []byte) (coverageData2, int, error) {
	var item coverageData2
	n := 0
	{
		if L := len(src); L < 2 {
			return coverageData2{}, 0, fmt.Errorf("reading coverageData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return coverageData2{}, 0, fmt.Errorf("reading coverageData2: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.Ranges = make([]rangeRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.Ranges {
			item.Ranges[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func (item *rangeRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.StartGlyphID = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.EndGlyphID = GlyphID(binary.BigEndian.Uint16(src[2:]))
	item.StartCoverageIndex = binary.BigEndian.Uint16(src[4:])
}
