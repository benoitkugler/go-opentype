package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from ot_gsub_src.go. DO NOT EDIT

func ParseAlternateSet(src []byte) (AlternateSet, int, error) {
	var item AlternateSet
	n := 0
	{
		if L := len(src); L < 2 {
			return AlternateSet{}, 0, fmt.Errorf("reading AlternateSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return AlternateSet{}, 0, fmt.Errorf("reading AlternateSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.alternateGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.alternateGlyphIDs {
			item.alternateGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseAlternateSubstitution(src []byte) (AlternateSubstitution, int, error) {
	var item AlternateSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverageOffset, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.alternateSetOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.alternateSetOffsets {
			item.alternateSetOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		read, err := item.customParseAlternateSets(src[:])
		if err != nil {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs1(src []byte) (ChainedContextualSubs1, int, error) {
	var item ChainedContextualSubs1
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverageOffset, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.chainedSeqRuleSetOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.chainedSeqRuleSetOffsets {
			item.chainedSeqRuleSetOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		item.rawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs2(src []byte) (ChainedContextualSubs2, int, error) {
	var item ChainedContextualSubs2
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[4:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.backtrackClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[6:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.inputClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 10 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[8:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.lookaheadClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 12 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[10:]))
		n += 2

		if L := len(src); L < 12+arrayLength*2 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", 12+arrayLength*2, L)
		}

		item.chainedClassSeqRuleSetOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.chainedClassSeqRuleSetOffsets {
			item.chainedClassSeqRuleSetOffsets[i] = Offset16(binary.BigEndian.Uint16(src[12+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		item.rawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs3(src []byte) (ChainedContextualSubs3, int, error) {
	var item ChainedContextualSubs3
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.backtrackCoverageOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.backtrackCoverageOffsets {
			item.backtrackCoverageOffsets[i] = Offset16(binary.BigEndian.Uint16(src[4+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.inputCoverageOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.inputCoverageOffsets {
			item.inputCoverageOffsets[i] = Offset16(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.lookaheadCoverageOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.lookaheadCoverageOffsets {
			item.lookaheadCoverageOffsets[i] = Offset16(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*4 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.seqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.seqLookupRecords {
			item.seqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	{

		item.rawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

func ParseChainedContextualSubstitution(src []byte) (ChainedContextualSubstitution, int, error) {
	var item ChainedContextualSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedContextualSubstitution{}, 0, fmt.Errorf("reading ChainedContextualSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = chainedContextualSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case chainedContextualSubsVersion1:
			item.data, read, err = ParseChainedContextualSubs1(src[:])
		case chainedContextualSubsVersion2:
			item.data, read, err = ParseChainedContextualSubs2(src[:])
		case chainedContextualSubsVersion3:
			item.data, read, err = ParseChainedContextualSubs3(src[:])
		default:
			err = fmt.Errorf("unsupported ChainedContextualSubsVersion %d", item.format)
		}
		if err != nil {
			return ChainedContextualSubstitution{}, 0, fmt.Errorf("reading ChainedContextualSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseClassDef(src []byte) (ClassDef, int, error) {
	var item ClassDef
	n := 0
	{
		if L := len(src); L < 2 {
			return ClassDef{}, 0, fmt.Errorf("reading ClassDef: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = classDefVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case classDefVersion1:
			item.data, read, err = parseClassDefData1(src[2:])
		case classDefVersion2:
			item.data, read, err = parseClassDefData2(src[2:])
		default:
			err = fmt.Errorf("unsupported classDefDataVersion %d", item.format)
		}
		if err != nil {
			return ClassDef{}, 0, fmt.Errorf("reading ClassDef: %s", err)
		}
		n += read
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs1(src []byte) (ContextualSubs1, int, error) {
	var item ContextualSubs1
	n := 2
	{
		if L := len(src); L < 4 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.seqRuleSetOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.seqRuleSetOffsets {
			item.seqRuleSetOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		item.rawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs2(src []byte) (ContextualSubs2, int, error) {
	var item ContextualSubs2
	n := 2
	{
		if L := len(src); L < 4 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[4:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.classDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[6:]))
		n += 2

		if L := len(src); L < 8+arrayLength*2 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", 8+arrayLength*2, L)
		}

		item.classSeqRuleSetOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.classSeqRuleSetOffsets {
			item.classSeqRuleSetOffsets[i] = Offset16(binary.BigEndian.Uint16(src[8+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		item.rawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs3(src []byte) (ContextualSubs3, int, error) {
	var item ContextualSubs3
	n := 2
	{
		if L := len(src); L < 6 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[5] // early bound checking
		item.glyphCount = binary.BigEndian.Uint16(src[2:])
		item.seqLookupCount = binary.BigEndian.Uint16(src[4:])
		n += 4
	}
	{
		arrayLength := int(item.glyphCount)

		if L := len(src); L < 6+arrayLength*2 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.coverageOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.coverageOffsets {
			item.coverageOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		arrayLength := int(item.seqLookupCount)

		if L := len(src); L < n+arrayLength*4 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.seqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.seqLookupRecords {
			item.seqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	{

		item.rawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

func ParseContextualSubstitution(src []byte) (ContextualSubstitution, int, error) {
	var item ContextualSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ContextualSubstitution{}, 0, fmt.Errorf("reading ContextualSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = contextualSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case contextualSubsVersion1:
			item.data, read, err = ParseContextualSubs1(src[:])
		case contextualSubsVersion2:
			item.data, read, err = ParseContextualSubs2(src[:])
		case contextualSubsVersion3:
			item.data, read, err = ParseContextualSubs3(src[:])
		default:
			err = fmt.Errorf("unsupported ContextualSubsVersion %d", item.format)
		}
		if err != nil {
			return ContextualSubstitution{}, 0, fmt.Errorf("reading ContextualSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseCoverage(src []byte) (Coverage, int, error) {
	var item Coverage
	n := 0
	{
		if L := len(src); L < 2 {
			return Coverage{}, 0, fmt.Errorf("reading Coverage: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = coverageVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case coverageVersion1:
			item.data, read, err = parseCoverageData1(src[2:])
		case coverageVersion2:
			item.data, read, err = parseCoverageData2(src[2:])
		default:
			err = fmt.Errorf("unsupported coverageDataVersion %d", item.format)
		}
		if err != nil {
			return Coverage{}, 0, fmt.Errorf("reading Coverage: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseExtensionSubstitution(src []byte) (ExtensionSubstitution, int, error) {
	var item ExtensionSubstitution
	n := 0
	{
		if L := len(src); L < 6 {
			return ExtensionSubstitution{}, 0, fmt.Errorf("reading ExtensionSubstitution: "+"EOF: expected length: 6, got %d", L)
		}
		_ = src[5] // early bound checking
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		item.extensionLookupType = binary.BigEndian.Uint16(src[2:])
		item.extensionOffset = Offset32(binary.BigEndian.Uint16(src[4:]))
		n += 6
	}
	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseLigature(src []byte) (Ligature, int, error) {
	var item Ligature
	n := 0
	{
		if L := len(src); L < 4 {
			return Ligature{}, 0, fmt.Errorf("reading Ligature: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.ligatureGlyph = glyphID(binary.BigEndian.Uint16(src[0:]))
		item.componentCount = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		arrayLength := int(item.componentCount - 1)

		if L := len(src); L < 4+arrayLength*2 {
			return Ligature{}, 0, fmt.Errorf("reading Ligature: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.componentGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.componentGlyphIDs {
			item.componentGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[4+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseLigatureSet(src []byte) (LigatureSet, int, error) {
	var item LigatureSet
	n := 0
	{
		if L := len(src); L < 2 {
			return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.ligatureOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.ligatureOffsets {
			item.ligatureOffsets[i] = Offset16(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		read, err := item.customParseLigatures(src[:])
		if err != nil {
			return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseLigatureSubstitution(src []byte) (LigatureSubstitution, int, error) {
	var item LigatureSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.ligatureSetOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.ligatureSetOffsets {
			item.ligatureSetOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		read, err := item.customParseLigatureSets(src[:])
		if err != nil {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseMultipleSubstitution(src []byte) (MultipleSubstitution, int, error) {
	var item MultipleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverageOffset, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.sequenceOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.sequenceOffsets {
			item.sequenceOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		read, err := item.customParseSequences(src[:])
		if err != nil {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseReverseChainSingleSubstitution(src []byte) (ReverseChainSingleSubstitution, int, error) {
	var item ReverseChainSingleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.backtrackCoverageOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.backtrackCoverageOffsets {
			item.backtrackCoverageOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.lookaheadCoverageOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.lookaheadCoverageOffsets {
			item.lookaheadCoverageOffsets[i] = Offset16(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.substituteGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.substituteGlyphIDs {
			item.substituteGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSequence(src []byte) (Sequence, int, error) {
	var item Sequence
	n := 0
	{
		if L := len(src); L < 2 {
			return Sequence{}, 0, fmt.Errorf("reading Sequence: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return Sequence{}, 0, fmt.Errorf("reading Sequence: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.substituteGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.substituteGlyphIDs {
			item.substituteGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSequenceLookupRecord(src []byte) (SequenceLookupRecord, int, error) {
	var item SequenceLookupRecord
	n := 0
	if L := len(src); L < 4 {
		return SequenceLookupRecord{}, 0, fmt.Errorf("reading SequenceLookupRecord: "+"EOF: expected length: 4, got %d", L)
	}
	item.mustParse(src)
	n += 4
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseSingleSubstData1(src []byte) (SingleSubstData1, int, error) {
	var item SingleSubstData1
	n := 2
	{
		if L := len(src); L < 4 {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: 2, got %d", L)
		}
		item.deltaGlyphID = int16(binary.BigEndian.Uint16(src[4:]))
		n += 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseSingleSubstData2(src []byte) (SingleSubstData2, int, error) {
	var item SingleSubstData2
	n := 2
	{
		if L := len(src); L < 4 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.substituteGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.substituteGlyphIDs {
			item.substituteGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSingleSubstitution(src []byte) (SingleSubstitution, int, error) {
	var item SingleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return SingleSubstitution{}, 0, fmt.Errorf("reading SingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = singleSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.substFormat {
		case singleSubsVersion1:
			item.data, read, err = ParseSingleSubstData1(src[:])
		case singleSubsVersion2:
			item.data, read, err = ParseSingleSubstData2(src[:])
		default:
			err = fmt.Errorf("unsupported SingleSubstDataVersion %d", item.substFormat)
		}
		if err != nil {
			return SingleSubstitution{}, 0, fmt.Errorf("reading SingleSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func (item *SequenceLookupRecord) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.sequenceIndex = binary.BigEndian.Uint16(src[0:])
	item.lookupListIndex = binary.BigEndian.Uint16(src[2:])
}

func (item *classRangeRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.startGlyphID = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.endGlyphID = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.class = binary.BigEndian.Uint16(src[4:])
}

func parseClassDefData1(src []byte) (classDefData1, int, error) {
	var item classDefData1
	n := 0
	{
		if L := len(src); L < 2 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: 2, got %d", L)
		}
		item.startGlyphID = glyphID(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*2 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.classValueArray = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.classValueArray {
			item.classValueArray[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func parseClassDefData2(src []byte) (classDefData2, int, error) {
	var item classDefData2
	n := 0
	{
		if L := len(src); L < 2 {
			return classDefData2{}, 0, fmt.Errorf("reading classDefData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return classDefData2{}, 0, fmt.Errorf("reading classDefData2: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.classRangeRecords = make([]classRangeRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.classRangeRecords {
			item.classRangeRecords[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func parseCoverageData1(src []byte) (coverageData1, int, error) {
	var item coverageData1
	n := 0
	{
		if L := len(src); L < 2 {
			return coverageData1{}, 0, fmt.Errorf("reading coverageData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return coverageData1{}, 0, fmt.Errorf("reading coverageData1: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.glyphs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.glyphs {
			item.glyphs[i] = glyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func parseCoverageData2(src []byte) (coverageData2, int, error) {
	var item coverageData2
	n := 0
	{
		if L := len(src); L < 2 {
			return coverageData2{}, 0, fmt.Errorf("reading coverageData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return coverageData2{}, 0, fmt.Errorf("reading coverageData2: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.ranges = make([]rangeRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.ranges {
			item.ranges[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func (item *rangeRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.startGlyphID = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.endGlyphID = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.startCoverageIndex = binary.BigEndian.Uint16(src[4:])
}
