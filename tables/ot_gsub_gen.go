package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from ot_gsub_src.go. DO NOT EDIT

func ParseAlternateSet(src []byte) (AlternateSet, int, error) {
	var item AlternateSet
	n := 0
	{
		if L := len(src); L < 2 {
			return AlternateSet{}, 0, fmt.Errorf("reading AlternateSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return AlternateSet{}, 0, fmt.Errorf("reading AlternateSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.alternateGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.alternateGlyphIDs {
			item.alternateGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseAlternateSubstitution(src []byte) (AlternateSubstitution, int, error) {
	var item AlternateSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverageOffset, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.alternateSets = make([]AlternateSet, arrayLength) // allocation guarded by the previous check
		for i := range item.alternateSets {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.alternateSets[i], _, err = ParseAlternateSet(src[offset:])
			if err != nil {
				return AlternateSubstitution{}, 0, fmt.Errorf("reading AlternateSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseChainedClassSequenceRule(src []byte) (ChainedClassSequenceRule, int, error) {
	var item ChainedClassSequenceRule
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.backtrackSequence = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.backtrackSequence {
			item.backtrackSequence[i] = binary.BigEndian.Uint16(src[2+i*2:])
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		item.inputGlyphCount = binary.BigEndian.Uint16(src[n:])
		n += 2
	}
	{
		arrayLength := int(item.inputGlyphCount - 1)

		if L := len(src); L < n+arrayLength*2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.inputSequence = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.inputSequence {
			item.inputSequence[i] = binary.BigEndian.Uint16(src[n+i*2:])
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.lookaheadGlyphCount = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.lookaheadGlyphCount {
			item.lookaheadGlyphCount[i] = binary.BigEndian.Uint16(src[n+i*2:])
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*4 {
			return ChainedClassSequenceRule{}, 0, fmt.Errorf("reading ChainedClassSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.seqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.seqLookupRecords {
			item.seqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseChainedClassSequenceRuleSet(src []byte) (ChainedClassSequenceRuleSet, int, error) {
	var item ChainedClassSequenceRuleSet
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedClassSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedClassSequenceRuleSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ChainedClassSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedClassSequenceRuleSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.chainedClassSeqRules = make([]ChainedClassSequenceRule, arrayLength) // allocation guarded by the previous check
		for i := range item.chainedClassSeqRules {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedClassSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedClassSequenceRuleSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.chainedClassSeqRules[i], _, err = ParseChainedClassSequenceRule(src[offset:])
			if err != nil {
				return ChainedClassSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedClassSequenceRuleSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs1(src []byte) (ChainedContextualSubs1, int, error) {
	var item ChainedContextualSubs1
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverageOffset, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.chainedSeqRuleSet = make([]ChainedSequenceRuleSet, arrayLength) // allocation guarded by the previous check
		for i := range item.chainedSeqRuleSet {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.chainedSeqRuleSet[i], _, err = ParseChainedSequenceRuleSet(src[offset:])
			if err != nil {
				return ChainedContextualSubs1{}, 0, fmt.Errorf("reading ChainedContextualSubs1: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs2(src []byte) (ChainedContextualSubs2, int, error) {
	var item ChainedContextualSubs2
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[4:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.backtrackClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[6:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.inputClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 10 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[8:]))
		n += 2
		if L := len(src); L < offset {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.lookaheadClassDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 12 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[10:]))
		n += 2

		if L := len(src); L < 12+arrayLength*2 {
			return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", 12+arrayLength*2, L)
		}

		item.chainedClassSeqRuleSet = make([]ChainedClassSequenceRuleSet, arrayLength) // allocation guarded by the previous check
		for i := range item.chainedClassSeqRuleSet {
			offset := int(binary.BigEndian.Uint16(src[12+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.chainedClassSeqRuleSet[i], _, err = ParseChainedClassSequenceRuleSet(src[offset:])
			if err != nil {
				return ChainedContextualSubs2{}, 0, fmt.Errorf("reading ChainedContextualSubs2: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseChainedContextualSubs3(src []byte) (ChainedContextualSubs3, int, error) {
	var item ChainedContextualSubs3
	n := 2
	{
		if L := len(src); L < 4 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.backtrackCoverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.backtrackCoverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[4+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.backtrackCoverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.inputCoverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.inputCoverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[n+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.inputCoverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.lookaheadCoverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.lookaheadCoverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[n+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.lookaheadCoverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*4 {
			return ChainedContextualSubs3{}, 0, fmt.Errorf("reading ChainedContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.seqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.seqLookupRecords {
			item.seqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseChainedContextualSubstitution(src []byte) (ChainedContextualSubstitution, int, error) {
	var item ChainedContextualSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedContextualSubstitution{}, 0, fmt.Errorf("reading ChainedContextualSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = chainedContextualSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case chainedContextualSubsVersion1:
			item.data, read, err = ParseChainedContextualSubs1(src[:])
		case chainedContextualSubsVersion2:
			item.data, read, err = ParseChainedContextualSubs2(src[:])
		case chainedContextualSubsVersion3:
			item.data, read, err = ParseChainedContextualSubs3(src[:])
		default:
			err = fmt.Errorf("unsupported ChainedContextualSubsVersion %d", item.format)
		}
		if err != nil {
			return ChainedContextualSubstitution{}, 0, fmt.Errorf("reading ChainedContextualSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseChainedSequenceRule(src []byte) (ChainedSequenceRule, int, error) {
	var item ChainedSequenceRule
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.backtrackSequence = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.backtrackSequence {
			item.backtrackSequence[i] = glyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		item.inputGlyphCount = binary.BigEndian.Uint16(src[n:])
		n += 2
	}
	{
		arrayLength := int(item.inputGlyphCount - 1)

		if L := len(src); L < n+arrayLength*2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.inputSequence = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.inputSequence {
			item.inputSequence[i] = glyphID(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		item.lookaheadSequence = glyphID(binary.BigEndian.Uint16(src[n:]))
		n += 2
	}
	{
		if L := len(src); L < n+2 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*4 {
			return ChainedSequenceRule{}, 0, fmt.Errorf("reading ChainedSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.seqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.seqLookupRecords {
			item.seqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseChainedSequenceRuleSet(src []byte) (ChainedSequenceRuleSet, int, error) {
	var item ChainedSequenceRuleSet
	n := 0
	{
		if L := len(src); L < 2 {
			return ChainedSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedSequenceRuleSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ChainedSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedSequenceRuleSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.chainedSeqRules = make([]ChainedSequenceRule, arrayLength) // allocation guarded by the previous check
		for i := range item.chainedSeqRules {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ChainedSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedSequenceRuleSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.chainedSeqRules[i], _, err = ParseChainedSequenceRule(src[offset:])
			if err != nil {
				return ChainedSequenceRuleSet{}, 0, fmt.Errorf("reading ChainedSequenceRuleSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseClassDef(src []byte) (ClassDef, int, error) {
	var item ClassDef
	n := 0
	{
		if L := len(src); L < 2 {
			return ClassDef{}, 0, fmt.Errorf("reading ClassDef: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = classDefVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case classDefVersion1:
			item.data, read, err = parseClassDefData1(src[2:])
		case classDefVersion2:
			item.data, read, err = parseClassDefData2(src[2:])
		default:
			err = fmt.Errorf("unsupported classDefDataVersion %d", item.format)
		}
		if err != nil {
			return ClassDef{}, 0, fmt.Errorf("reading ClassDef: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseClassSequenceRule(src []byte) (ClassSequenceRule, int, error) {
	var item ClassSequenceRule
	n := 0
	{
		if L := len(src); L < 4 {
			return ClassSequenceRule{}, 0, fmt.Errorf("reading ClassSequenceRule: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.glyphCount = binary.BigEndian.Uint16(src[0:])
		item.seqLookupCount = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		arrayLength := int(item.glyphCount - 1)

		if L := len(src); L < 4+arrayLength*2 {
			return ClassSequenceRule{}, 0, fmt.Errorf("reading ClassSequenceRule: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.inputSequence = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.inputSequence {
			item.inputSequence[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLength * 2
	}
	{
		arrayLength := int(item.seqLookupCount)

		if L := len(src); L < n+arrayLength*4 {
			return ClassSequenceRule{}, 0, fmt.Errorf("reading ClassSequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.seqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.seqLookupRecords {
			item.seqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseClassSequenceRuleSet(src []byte) (ClassSequenceRuleSet, int, error) {
	var item ClassSequenceRuleSet
	n := 0
	{
		if L := len(src); L < 2 {
			return ClassSequenceRuleSet{}, 0, fmt.Errorf("reading ClassSequenceRuleSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return ClassSequenceRuleSet{}, 0, fmt.Errorf("reading ClassSequenceRuleSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.classSeqRule = make([]ClassSequenceRule, arrayLength) // allocation guarded by the previous check
		for i := range item.classSeqRule {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ClassSequenceRuleSet{}, 0, fmt.Errorf("reading ClassSequenceRuleSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.classSeqRule[i], _, err = ParseClassSequenceRule(src[offset:])
			if err != nil {
				return ClassSequenceRuleSet{}, 0, fmt.Errorf("reading ClassSequenceRuleSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs1(src []byte) (ContextualSubs1, int, error) {
	var item ContextualSubs1
	n := 2
	{
		if L := len(src); L < 4 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.seqRuleSet = make([]SequenceRuleSet, arrayLength) // allocation guarded by the previous check
		for i := range item.seqRuleSet {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.seqRuleSet[i], _, err = ParseSequenceRuleSet(src[offset:])
			if err != nil {
				return ContextualSubs1{}, 0, fmt.Errorf("reading ContextualSubs1: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs2(src []byte) (ContextualSubs2, int, error) {
	var item ContextualSubs2
	n := 2
	{
		if L := len(src); L < 4 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[4:]))
		n += 2
		if L := len(src); L < offset {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.classDef, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[6:]))
		n += 2

		if L := len(src); L < 8+arrayLength*2 {
			return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", 8+arrayLength*2, L)
		}

		item.classSeqRuleSet = make([]ClassSequenceRuleSet, arrayLength) // allocation guarded by the previous check
		for i := range item.classSeqRuleSet {
			offset := int(binary.BigEndian.Uint16(src[8+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.classSeqRuleSet[i], _, err = ParseClassSequenceRuleSet(src[offset:])
			if err != nil {
				return ContextualSubs2{}, 0, fmt.Errorf("reading ContextualSubs2: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseContextualSubs3(src []byte) (ContextualSubs3, int, error) {
	var item ContextualSubs3
	n := 2
	{
		if L := len(src); L < 6 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[5] // early bound checking
		item.glyphCount = binary.BigEndian.Uint16(src[2:])
		item.seqLookupCount = binary.BigEndian.Uint16(src[4:])
		n += 4
	}
	{
		arrayLength := int(item.glyphCount)

		if L := len(src); L < 6+arrayLength*2 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.coverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.coverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.coverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		arrayLength := int(item.seqLookupCount)

		if L := len(src); L < n+arrayLength*4 {
			return ContextualSubs3{}, 0, fmt.Errorf("reading ContextualSubs3: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.seqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.seqLookupRecords {
			item.seqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseContextualSubstitution(src []byte) (ContextualSubstitution, int, error) {
	var item ContextualSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ContextualSubstitution{}, 0, fmt.Errorf("reading ContextualSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = contextualSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case contextualSubsVersion1:
			item.data, read, err = ParseContextualSubs1(src[:])
		case contextualSubsVersion2:
			item.data, read, err = ParseContextualSubs2(src[:])
		case contextualSubsVersion3:
			item.data, read, err = ParseContextualSubs3(src[:])
		default:
			err = fmt.Errorf("unsupported ContextualSubsVersion %d", item.format)
		}
		if err != nil {
			return ContextualSubstitution{}, 0, fmt.Errorf("reading ContextualSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseCoverage(src []byte) (Coverage, int, error) {
	var item Coverage
	n := 0
	{
		if L := len(src); L < 2 {
			return Coverage{}, 0, fmt.Errorf("reading Coverage: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = coverageVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case coverageVersion1:
			item.data, read, err = parseCoverageData1(src[2:])
		case coverageVersion2:
			item.data, read, err = parseCoverageData2(src[2:])
		default:
			err = fmt.Errorf("unsupported coverageDataVersion %d", item.format)
		}
		if err != nil {
			return Coverage{}, 0, fmt.Errorf("reading Coverage: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseExtensionSubstitution(src []byte) (ExtensionSubstitution, int, error) {
	var item ExtensionSubstitution
	n := 0
	{
		if L := len(src); L < 6 {
			return ExtensionSubstitution{}, 0, fmt.Errorf("reading ExtensionSubstitution: "+"EOF: expected length: 6, got %d", L)
		}
		_ = src[5] // early bound checking
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		item.extensionLookupType = binary.BigEndian.Uint16(src[2:])
		item.extensionOffset = Offset32(binary.BigEndian.Uint16(src[4:]))
		n += 6
	}
	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseLigature(src []byte) (Ligature, int, error) {
	var item Ligature
	n := 0
	{
		if L := len(src); L < 4 {
			return Ligature{}, 0, fmt.Errorf("reading Ligature: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.ligatureGlyph = glyphID(binary.BigEndian.Uint16(src[0:]))
		item.componentCount = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		arrayLength := int(item.componentCount - 1)

		if L := len(src); L < 4+arrayLength*2 {
			return Ligature{}, 0, fmt.Errorf("reading Ligature: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.componentGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.componentGlyphIDs {
			item.componentGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[4+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseLigatureSet(src []byte) (LigatureSet, int, error) {
	var item LigatureSet
	n := 0
	{
		if L := len(src); L < 2 {
			return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.Ligatures = make([]Ligature, arrayLength) // allocation guarded by the previous check
		for i := range item.Ligatures {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.Ligatures[i], _, err = ParseLigature(src[offset:])
			if err != nil {
				return LigatureSet{}, 0, fmt.Errorf("reading LigatureSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseLigatureSubstitution(src []byte) (LigatureSubstitution, int, error) {
	var item LigatureSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.ligatureSets = make([]LigatureSet, arrayLength) // allocation guarded by the previous check
		for i := range item.ligatureSets {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.ligatureSets[i], _, err = ParseLigatureSet(src[offset:])
			if err != nil {
				return LigatureSubstitution{}, 0, fmt.Errorf("reading LigatureSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseMultipleSubstitution(src []byte) (MultipleSubstitution, int, error) {
	var item MultipleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverageOffset, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.sequences = make([]Sequence, arrayLength) // allocation guarded by the previous check
		for i := range item.sequences {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.sequences[i], _, err = ParseSequence(src[offset:])
			if err != nil {
				return MultipleSubstitution{}, 0, fmt.Errorf("reading MultipleSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseReverseChainSingleSubstitution(src []byte) (ReverseChainSingleSubstitution, int, error) {
	var item ReverseChainSingleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.backtrackCoverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.backtrackCoverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[6+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.backtrackCoverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.lookaheadCoverageOffsets = make([]Coverage, arrayLength) // allocation guarded by the previous check
		for i := range item.lookaheadCoverageOffsets {
			offset := int(binary.BigEndian.Uint16(src[n+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.lookaheadCoverageOffsets[i], _, err = ParseCoverage(src[offset:])
			if err != nil {
				return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: %s", err)
			}

		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[n:]))
		n += 2

		if L := len(src); L < n+arrayLength*2 {
			return ReverseChainSingleSubstitution{}, 0, fmt.Errorf("reading ReverseChainSingleSubstitution: "+"EOF: expected length: %d, got %d", n+arrayLength*2, L)
		}

		item.substituteGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.substituteGlyphIDs {
			item.substituteGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSequence(src []byte) (Sequence, int, error) {
	var item Sequence
	n := 0
	{
		if L := len(src); L < 2 {
			return Sequence{}, 0, fmt.Errorf("reading Sequence: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return Sequence{}, 0, fmt.Errorf("reading Sequence: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.substituteGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.substituteGlyphIDs {
			item.substituteGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSequenceLookupRecord(src []byte) (SequenceLookupRecord, int, error) {
	var item SequenceLookupRecord
	n := 0
	if L := len(src); L < 4 {
		return SequenceLookupRecord{}, 0, fmt.Errorf("reading SequenceLookupRecord: "+"EOF: expected length: 4, got %d", L)
	}
	item.mustParse(src)
	n += 4
	return item, n, nil
}

func ParseSequenceRule(src []byte) (SequenceRule, int, error) {
	var item SequenceRule
	n := 0
	{
		if L := len(src); L < 4 {
			return SequenceRule{}, 0, fmt.Errorf("reading SequenceRule: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.glyphCount = binary.BigEndian.Uint16(src[0:])
		item.seqLookupCount = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		arrayLength := int(item.glyphCount - 1)

		if L := len(src); L < 4+arrayLength*2 {
			return SequenceRule{}, 0, fmt.Errorf("reading SequenceRule: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.inputSequence = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.inputSequence {
			item.inputSequence[i] = glyphID(binary.BigEndian.Uint16(src[4+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		arrayLength := int(item.seqLookupCount)

		if L := len(src); L < n+arrayLength*4 {
			return SequenceRule{}, 0, fmt.Errorf("reading SequenceRule: "+"EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.seqLookupRecords = make([]SequenceLookupRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.seqLookupRecords {
			item.seqLookupRecords[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseSequenceRuleSet(src []byte) (SequenceRuleSet, int, error) {
	var item SequenceRuleSet
	n := 0
	{
		if L := len(src); L < 2 {
			return SequenceRuleSet{}, 0, fmt.Errorf("reading SequenceRuleSet: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return SequenceRuleSet{}, 0, fmt.Errorf("reading SequenceRuleSet: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.seqRule = make([]SequenceRule, arrayLength) // allocation guarded by the previous check
		for i := range item.seqRule {
			offset := int(binary.BigEndian.Uint16(src[2+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return SequenceRuleSet{}, 0, fmt.Errorf("reading SequenceRuleSet: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.seqRule[i], _, err = ParseSequenceRule(src[offset:])
			if err != nil {
				return SequenceRuleSet{}, 0, fmt.Errorf("reading SequenceRuleSet: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseSingleSubstData1(src []byte) (SingleSubstData1, int, error) {
	var item SingleSubstData1
	n := 2
	{
		if L := len(src); L < 4 {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return SingleSubstData1{}, 0, fmt.Errorf("reading SingleSubstData1: "+"EOF: expected length: 2, got %d", L)
		}
		item.deltaGlyphID = int16(binary.BigEndian.Uint16(src[4:]))
		n += 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseSingleSubstData2(src []byte) (SingleSubstData2, int, error) {
	var item SingleSubstData2
	n := 2
	{
		if L := len(src); L < 4 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return SingleSubstData2{}, 0, fmt.Errorf("reading SingleSubstData2: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.substituteGlyphIDs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.substituteGlyphIDs {
			item.substituteGlyphIDs[i] = glyphID(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseSingleSubstitution(src []byte) (SingleSubstitution, int, error) {
	var item SingleSubstitution
	n := 0
	{
		if L := len(src); L < 2 {
			return SingleSubstitution{}, 0, fmt.Errorf("reading SingleSubstitution: "+"EOF: expected length: 2, got %d", L)
		}
		item.substFormat = singleSubsVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.substFormat {
		case singleSubsVersion1:
			item.data, read, err = ParseSingleSubstData1(src[:])
		case singleSubsVersion2:
			item.data, read, err = ParseSingleSubstData2(src[:])
		default:
			err = fmt.Errorf("unsupported SingleSubstDataVersion %d", item.substFormat)
		}
		if err != nil {
			return SingleSubstitution{}, 0, fmt.Errorf("reading SingleSubstitution: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func (item *SequenceLookupRecord) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.sequenceIndex = binary.BigEndian.Uint16(src[0:])
	item.lookupListIndex = binary.BigEndian.Uint16(src[2:])
}

func (item *classRangeRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.startGlyphID = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.endGlyphID = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.class = binary.BigEndian.Uint16(src[4:])
}

func parseClassDefData1(src []byte) (classDefData1, int, error) {
	var item classDefData1
	n := 0
	{
		if L := len(src); L < 2 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: 2, got %d", L)
		}
		item.startGlyphID = glyphID(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*2 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.classValueArray = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.classValueArray {
			item.classValueArray[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func parseClassDefData2(src []byte) (classDefData2, int, error) {
	var item classDefData2
	n := 0
	{
		if L := len(src); L < 2 {
			return classDefData2{}, 0, fmt.Errorf("reading classDefData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return classDefData2{}, 0, fmt.Errorf("reading classDefData2: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.classRangeRecords = make([]classRangeRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.classRangeRecords {
			item.classRangeRecords[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func parseCoverageData1(src []byte) (coverageData1, int, error) {
	var item coverageData1
	n := 0
	{
		if L := len(src); L < 2 {
			return coverageData1{}, 0, fmt.Errorf("reading coverageData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return coverageData1{}, 0, fmt.Errorf("reading coverageData1: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.glyphs = make([]glyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.glyphs {
			item.glyphs[i] = glyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func parseCoverageData2(src []byte) (coverageData2, int, error) {
	var item coverageData2
	n := 0
	{
		if L := len(src); L < 2 {
			return coverageData2{}, 0, fmt.Errorf("reading coverageData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return coverageData2{}, 0, fmt.Errorf("reading coverageData2: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.ranges = make([]rangeRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.ranges {
			item.ranges[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func (item *rangeRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.startGlyphID = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.endGlyphID = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.startCoverageIndex = binary.BigEndian.Uint16(src[4:])
}
