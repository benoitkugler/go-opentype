package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from glyf_src.go. DO NOT EDIT

func ParseCompositeGlyph(src []byte) (CompositeGlyph, int, error) {
	var item CompositeGlyph
	n := 0
	{

		item.RawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseGlyph(src []byte) (Glyph, int, error) {
	var item Glyph
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading Glyph: "+"EOF: expected length: 10, got %d", L)
	}
	_ = src[9] // early bound checking
	item.numberOfContours = int16(binary.BigEndian.Uint16(src[0:]))
	item.XMin = int16(binary.BigEndian.Uint16(src[2:]))
	item.YMin = int16(binary.BigEndian.Uint16(src[4:]))
	item.XMax = int16(binary.BigEndian.Uint16(src[6:]))
	item.YMax = int16(binary.BigEndian.Uint16(src[8:]))
	n += 10

	{

		read, err := item.customParseData(src[10:])
		if err != nil {
			return item, 0, fmt.Errorf("reading Glyph: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseSimpleGlyph(src []byte) (SimpleGlyph, int, error) {
	var item SimpleGlyph
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading SimpleGlyph: "+"EOF: expected length: 4, got %d", L)
	}
	_ = src[3] // early bound checking
	item.EndPtsOfContours = binary.BigEndian.Uint16(src[0:])
	arrayLengthItemInstructions := int(binary.BigEndian.Uint16(src[2:]))
	n += 4

	{

		L := int(4 + arrayLengthItemInstructions)
		if len(src) < L {
			return item, 0, fmt.Errorf("reading SimpleGlyph: "+"EOF: expected length: %d, got %d", L, len(src))
		}
		item.Instructions = src[4:L]
		n = L
	}
	{

		item.RawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}
