package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from aat_ankr_src.go. DO NOT EDIT

func (item *AnrkAnchor) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.X = int16(binary.BigEndian.Uint16(src[0:]))
	item.Y = int16(binary.BigEndian.Uint16(src[2:]))
}

func ParseAnkr(src []byte, valuesCount int) (Ankr, int, error) {
	var item Ankr
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading Ankr: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.version = binary.BigEndian.Uint16(src[0:])
	item.flags = binary.BigEndian.Uint16(src[2:])
	offsetLookupTable := int(binary.BigEndian.Uint32(src[4:]))
	offsetGlyphDataTable := int(binary.BigEndian.Uint32(src[8:]))
	n += 12

	{

		if offsetLookupTable != 0 { // ignore null offset
			if L := len(src); L < offsetLookupTable {
				return item, 0, fmt.Errorf("reading Ankr: "+"EOF: expected length: %d, got %d", offsetLookupTable, L)
			}

			var (
				err  error
				read int
			)
			item.LookupTable, read, err = parseAatLookup(src[offsetLookupTable:], valuesCount)
			if err != nil {
				return item, 0, fmt.Errorf("reading Ankr: %s", err)
			}
			offsetLookupTable += read

		}
	}
	{

		if offsetGlyphDataTable != 0 { // ignore null offset
			if L := len(src); L < offsetGlyphDataTable {
				return item, 0, fmt.Errorf("reading Ankr: "+"EOF: expected length: %d, got %d", offsetGlyphDataTable, L)
			}

			item.GlyphDataTable = src[offsetGlyphDataTable:]
			offsetGlyphDataTable = len(src)
		}
	}
	return item, n, nil
}

func ParseAnrkAnchor(src []byte) (AnrkAnchor, int, error) {
	var item AnrkAnchor
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading AnrkAnchor: "+"EOF: expected length: 4, got %d", L)
	}
	item.mustParse(src)
	n += 4
	return item, n, nil
}

func (item *binSearchHeader) mustParse(src []byte) {
	_ = src[9] // early bound checking
	item.unitSize = binary.BigEndian.Uint16(src[0:])
	item.nUnits = binary.BigEndian.Uint16(src[2:])
	item.searchRange = binary.BigEndian.Uint16(src[4:])
	item.entrySelector = binary.BigEndian.Uint16(src[6:])
	item.rangeShift = binary.BigEndian.Uint16(src[8:])
}

func (item *lookupRecord2) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.lastGlyph = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.firstGlyph = GlyphID(binary.BigEndian.Uint16(src[2:]))
	item.value = binary.BigEndian.Uint16(src[4:])
}

func (item *loopkupRecord4) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.lastGlyph = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.firstGlyph = GlyphID(binary.BigEndian.Uint16(src[2:]))
	item.offsetToValues = binary.BigEndian.Uint16(src[4:])
}

func (item *loopkupRecord6) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.glyph = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.value = binary.BigEndian.Uint16(src[2:])
}

func parseAatLookup(src []byte, valuesCount int) (aatLookup, int, error) {
	var item aatLookup
	n := 0
	if L := len(src); L < 2 {
		return item, 0, fmt.Errorf("reading aatLookup: "+"EOF: expected length: 2, got %d", L)
	}
	item.version = aatLookupVersion(binary.BigEndian.Uint16(src[0:]))
	n += 2

	{
		var (
			read int
			err  error
		)
		switch item.version {
		case aatLookupTableVersion0:
			item.table, read, err = parseAatLookupTable0(src[2:], valuesCount)
		case aatLookupTableVersion10:
			item.table, read, err = parseAatLookupTable10(src[2:])
		case aatLookupTableVersion2:
			item.table, read, err = parseAatLookupTable2(src[2:])
		case aatLookupTableVersion4:
			item.table, read, err = parseAatLookupTable4(src[2:])
		case aatLookupTableVersion6:
			item.table, read, err = parseAatLookupTable6(src[2:])
		case aatLookupTableVersion8:
			item.table, read, err = parseAatLookupTable8(src[2:])
		default:
			err = fmt.Errorf("unsupported aatLookupTableVersion %d", item.version)
		}
		if err != nil {
			return item, 0, fmt.Errorf("reading aatLookup: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func parseAatLookupTable0(src []byte, valuesCount int) (aatLookupTable0, int, error) {
	var item aatLookupTable0
	n := 0
	{

		if L := len(src); L < valuesCount*2 {
			return item, 0, fmt.Errorf("reading aatLookupTable0: "+"EOF: expected length: %d, got %d", valuesCount*2, L)
		}

		item.values = make([]uint16, valuesCount) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(src[i*2:])
		}
		n += valuesCount * 2
	}
	return item, n, nil
}

func parseAatLookupTable10(src []byte) (aatLookupTable10, int, error) {
	var item aatLookupTable10
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading aatLookupTable10: "+"EOF: expected length: 6, got %d", L)
	}
	_ = src[5] // early bound checking
	item.unitSize = binary.BigEndian.Uint16(src[0:])
	item.firstGlyph = GlyphID(binary.BigEndian.Uint16(src[2:]))
	arrayLengthValues := int(binary.BigEndian.Uint16(src[4:]))
	n += 6

	{

		if L := len(src); L < 6+arrayLengthValues*2 {
			return item, 0, fmt.Errorf("reading aatLookupTable10: "+"EOF: expected length: %d, got %d", 6+arrayLengthValues*2, L)
		}

		item.values = make([]uint16, arrayLengthValues) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(src[6+i*2:])
		}
		n += arrayLengthValues * 2
	}
	return item, n, nil
}

func parseAatLookupTable2(src []byte) (aatLookupTable2, int, error) {
	var item aatLookupTable2
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading aatLookupTable2: "+"EOF: expected length: 10, got %d", L)
	}
	item.binSearchHeader.mustParse(src[0:])
	n += 10

	{
		arrayLength := int(item.nUnits)

		if L := len(src); L < 10+arrayLength*6 {
			return item, 0, fmt.Errorf("reading aatLookupTable2: "+"EOF: expected length: %d, got %d", 10+arrayLength*6, L)
		}

		item.records = make([]lookupRecord2, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(src[10+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func parseAatLookupTable4(src []byte) (aatLookupTable4, int, error) {
	var item aatLookupTable4
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading aatLookupTable4: "+"EOF: expected length: 10, got %d", L)
	}
	item.binSearchHeader.mustParse(src[0:])
	n += 10

	{
		arrayLength := int(item.nUnits)

		if L := len(src); L < 10+arrayLength*6 {
			return item, 0, fmt.Errorf("reading aatLookupTable4: "+"EOF: expected length: %d, got %d", 10+arrayLength*6, L)
		}

		item.records = make([]loopkupRecord4, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(src[10+i*6:])
		}
		n += arrayLength * 6
	}
	{

		item.rawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

func parseAatLookupTable6(src []byte) (aatLookupTable6, int, error) {
	var item aatLookupTable6
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading aatLookupTable6: "+"EOF: expected length: 10, got %d", L)
	}
	item.binSearchHeader.mustParse(src[0:])
	n += 10

	{
		arrayLength := int(item.nUnits)

		if L := len(src); L < 10+arrayLength*4 {
			return item, 0, fmt.Errorf("reading aatLookupTable6: "+"EOF: expected length: %d, got %d", 10+arrayLength*4, L)
		}

		item.records = make([]loopkupRecord6, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(src[10+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func parseAatLookupTable8(src []byte) (aatLookupTable8, int, error) {
	var item aatLookupTable8
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading aatLookupTable8: "+"EOF: expected length: 4, got %d", L)
	}
	_ = src[3] // early bound checking
	item.firstGlyph = GlyphID(binary.BigEndian.Uint16(src[0:]))
	arrayLengthValues := int(binary.BigEndian.Uint16(src[2:]))
	n += 4

	{

		if L := len(src); L < 4+arrayLengthValues*2 {
			return item, 0, fmt.Errorf("reading aatLookupTable8: "+"EOF: expected length: %d, got %d", 4+arrayLengthValues*2, L)
		}

		item.values = make([]uint16, arrayLengthValues) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLengthValues * 2
	}
	return item, n, nil
}
