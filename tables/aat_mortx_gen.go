package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from aat_mortx.go. DO NOT EDIT

func ParseMorx(src []byte) (Morx, int, error) {
	var item Morx
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 8 {
			return Morx{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
		}

		_ = subSlice[7] // early bound checking
		item.version = binary.BigEndian.Uint16(subSlice[0:])
		item.unused = binary.BigEndian.Uint16(subSlice[2:])
		item.nChains = binary.BigEndian.Uint32(subSlice[4:])
		n += 8

	}
	{
		arrayLength := int(item.nChains)
		for i := 0; i < arrayLength; i++ {
			elem, read, err := parseMorxChain(src[n:])
			if err != nil {
				return Morx{}, 0, err
			}
			item.chains = append(item.chains, elem)
			n += read
		}
	}
	return item, n, nil
}
func ParseMorxChainSubtable(src []byte, valuesNum int) (MorxChainSubtable, int, error) {
	var item MorxChainSubtable
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 12 {
			return MorxChainSubtable{}, 0, fmt.Errorf("EOF: expected length: 12, got %d", L)
		}

		_ = subSlice[11] // early bound checking
		item.length = binary.BigEndian.Uint32(subSlice[0:])
		item.coverage = subSlice[4]
		for i := range item.ignored {
			item.ignored[i] = subSlice[5+i]
		}
		item.version = morxSubtableVersion(subSlice[7])
		item.subFeatureFlags = binary.BigEndian.Uint32(subSlice[8:])
		n += 12

	}
	{
		var read int
		var err error
		switch item.version {
		case morxSubtableVersionContextual:
			item.subtableContent, read, err = parseMorxSubtableContextual(src[n:])
		case morxSubtableVersionInsertion:
			item.subtableContent, read, err = parseMorxSubtableInsertion(src[n:])
		case morxSubtableVersionLigature:
			item.subtableContent, read, err = parseMorxSubtableLigature(src[n:])
		case morxSubtableVersionNonContextual:
			item.subtableContent, read, err = parseMorxSubtableNonContextual(src[n:], valuesNum)
		case morxSubtableVersionRearrangement:
			item.subtableContent, read, err = parseMorxSubtableRearrangement(src[n:])
		default:
			err = fmt.Errorf("unsupported morxSubtableVersion %d", item.version)
		}
		if err != nil {
			return MorxChainSubtable{}, 0, err
		}
		n += read
	}
	return item, n, nil
}
func (item *aatFeature) mustParse(src []byte) {
	_ = src[11] // early bound checking
	item.featureType = binary.BigEndian.Uint16(src[0:])
	item.featureSetting = binary.BigEndian.Uint16(src[2:])
	item.enableFlags = binary.BigEndian.Uint32(src[4:])
	item.disableFlags = binary.BigEndian.Uint32(src[8:])
}
func parseAatLookup(src []byte, valuesNum int) (aatLookup, int, error) {
	var item aatLookup
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookup{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}

		_ = subSlice[1] // early bound checking
		item.version = aatLookupVersion(binary.BigEndian.Uint16(subSlice[0:]))
		n += 2

	}
	{
		var read int
		var err error
		switch item.version {
		case aatLookupTableVersion0:
			item.table, read, err = parseAatLookupTable0(src[n:], valuesNum)
		case aatLookupTableVersion10:
			item.table, read, err = parseAatLookupTable10(src[n:])
		case aatLookupTableVersion2:
			item.table, read, err = parseAatLookupTable2(src[n:])
		case aatLookupTableVersion4:
			item.table, read, err = parseAatLookupTable4(src[n:])
		case aatLookupTableVersion6:
			item.table, read, err = parseAatLookupTable6(src[n:])
		case aatLookupTableVersion8:
			item.table, read, err = parseAatLookupTable8(src[n:])
		default:
			err = fmt.Errorf("unsupported aatLookupTableVersion %d", item.version)
		}
		if err != nil {
			return aatLookup{}, 0, err
		}
		n += read
	}
	return item, n, nil
}
func parseAatLookupTable0(src []byte, valuesNum int) (aatLookupTable0, int, error) {
	var item aatLookupTable0
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < +valuesNum*2 {
			return aatLookupTable0{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +valuesNum*2, L)
		}

		item.values = make([]uint16, valuesNum) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(subSlice[+i*2:])
		}

		n += valuesNum * 2
	}
	return item, n, nil
}
func parseAatLookupTable10(src []byte) (aatLookupTable10, int, error) {
	var item aatLookupTable10
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 4 {
			return aatLookupTable10{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
		}

		_ = subSlice[3] // early bound checking
		item.unitSize = binary.BigEndian.Uint16(subSlice[0:])
		item.firstGlyph = glyphID(binary.BigEndian.Uint16(subSlice[2:]))
		n += 4

	}
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookupTable10{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2, L)
		}
		arrayLength := int(binary.BigEndian.Uint16(subSlice[:]))
		if L := len(subSlice); L < 2+arrayLength*2 {
			return aatLookupTable10{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.values = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(subSlice[2+i*2:])
		}

		n += 2 + arrayLength*2
	}
	return item, n, nil
}
func parseAatLookupTable2(src []byte) (aatLookupTable2, int, error) {
	var item aatLookupTable2
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTable2{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*6 {
			return aatLookupTable2{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*6, L)
		}

		item.records = make([]lookupRecord2, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*6:])
		}

		n += arrayLength * 6
	}
	return item, n, nil
}
func parseAatLookupTable4(src []byte) (aatLookupTable4, int, error) {
	var item aatLookupTable4
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTable4{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*6 {
			return aatLookupTable4{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*6, L)
		}

		item.records = make([]loopkupRecord4, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*6:])
		}

		n += arrayLength * 6
	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}
func parseAatLookupTable6(src []byte) (aatLookupTable6, int, error) {
	var item aatLookupTable6
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTable6{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*4 {
			return aatLookupTable6{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*4, L)
		}

		item.records = make([]loopkupRecord6, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*4:])
		}

		n += arrayLength * 4
	}
	return item, n, nil
}
func (item *aatSTXHeader) mustParse(src []byte) {
	_ = src[15] // early bound checking
	item.stateSize = binary.BigEndian.Uint32(src[0:])
	item.classTable = binary.BigEndian.Uint32(src[4:])
	item.stateArray = binary.BigEndian.Uint32(src[8:])
	item.entryTable = binary.BigEndian.Uint32(src[12:])
}
func (item *binSearchHeader) mustParse(src []byte) {
	_ = src[9] // early bound checking
	item.unitSize = binary.BigEndian.Uint16(src[0:])
	item.nUnits = binary.BigEndian.Uint16(src[2:])
	item.searchRange = binary.BigEndian.Uint16(src[4:])
	item.entrySelector = binary.BigEndian.Uint16(src[6:])
	item.rangeShift = binary.BigEndian.Uint16(src[8:])
}
func (item *lookupRecord2) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.lastGlyph = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.firstGlyph = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.value = binary.BigEndian.Uint16(src[4:])
}
func (item *loopkupRecord4) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.lastGlyph = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.firstGlyph = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.offsetToValues = binary.BigEndian.Uint16(src[4:])
}
func (item *loopkupRecord6) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.glyph = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.value = binary.BigEndian.Uint16(src[2:])
}
func parseMorxChain(src []byte) (morxChain, int, error) {
	var item morxChain
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 16 {
			return morxChain{}, 0, fmt.Errorf("EOF: expected length: 16, got %d", L)
		}

		_ = subSlice[15] // early bound checking
		item.flags = binary.BigEndian.Uint32(subSlice[0:])
		item.chainLength = binary.BigEndian.Uint32(subSlice[4:])
		item.nFeatureEntries = binary.BigEndian.Uint32(subSlice[8:])
		item.nSubtable = binary.BigEndian.Uint32(subSlice[12:])
		n += 16

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nFeatureEntries)
		if L := len(subSlice); L < +arrayLength*12 {
			return morxChain{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*12, L)
		}

		item.features = make([]aatFeature, arrayLength) // allocation guarded by the previous check
		for i := range item.features {
			item.features[i].mustParse(subSlice[+i*12:])
		}

		n += arrayLength * 12
	}

	L := int(item.chainLength)
	if len(src) < L {
		return morxChain{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", L, len(src))
	}
	item.subtablesData = src[n:item.chainLength]
	n = L

	return item, n, nil
}
func parseMorxSubtableContextual(src []byte) (morxSubtableContextual, int, error) {
	var item morxSubtableContextual
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 20 {
			return morxSubtableContextual{}, 0, fmt.Errorf("EOF: expected length: 20, got %d", L)
		}

		_ = subSlice[19] // early bound checking
		item.aatSTXHeader.mustParse(subSlice[0:])
		item.substitutionTableOffset = binary.BigEndian.Uint32(subSlice[16:])
		n += 20

	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}
func parseMorxSubtableInsertion(src []byte) (morxSubtableInsertion, int, error) {
	var item morxSubtableInsertion
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 20 {
			return morxSubtableInsertion{}, 0, fmt.Errorf("EOF: expected length: 20, got %d", L)
		}

		_ = subSlice[19] // early bound checking
		item.aatSTXHeader.mustParse(subSlice[0:])
		item.insertionActionOffset = binary.BigEndian.Uint32(subSlice[16:])
		n += 20

	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}
func parseMorxSubtableLigature(src []byte) (morxSubtableLigature, int, error) {
	var item morxSubtableLigature
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 28 {
			return morxSubtableLigature{}, 0, fmt.Errorf("EOF: expected length: 28, got %d", L)
		}

		_ = subSlice[27] // early bound checking
		item.aatSTXHeader.mustParse(subSlice[0:])
		item.ligActionOffset = binary.BigEndian.Uint32(subSlice[16:])
		item.componentOffset = binary.BigEndian.Uint32(subSlice[20:])
		item.ligatureOffset = binary.BigEndian.Uint32(subSlice[24:])
		n += 28

	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}
func parseMorxSubtableNonContextual(src []byte, valuesNum int) (morxSubtableNonContextual, int, error) {
	var item morxSubtableNonContextual
	n := 0

	{
		var read int
		var err error
		item.table, read, err = parseAatLookup(src[n:], valuesNum)
		if err != nil {
			return morxSubtableNonContextual{}, 0, err
		}
		n += read
	}
	return item, n, nil
}
func parseMorxSubtableRearrangement(src []byte) (morxSubtableRearrangement, int, error) {
	var item morxSubtableRearrangement
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 16 {
			return morxSubtableRearrangement{}, 0, fmt.Errorf("EOF: expected length: 16, got %d", L)
		}

		_ = subSlice[15] // early bound checking
		item.aatSTXHeader.mustParse(subSlice[0:])
		n += 16

	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}
