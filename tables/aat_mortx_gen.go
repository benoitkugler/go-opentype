package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from aat_mortx_src.go. DO NOT EDIT

func ParseMorx(src []byte) (Morx, int, error) {
	var item Morx
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading Morx: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.version = binary.BigEndian.Uint16(src[0:])
	item.unused = binary.BigEndian.Uint16(src[2:])
	item.nChains = binary.BigEndian.Uint32(src[4:])
	n += 8

	{
		arrayLength := int(item.nChains)

		offset := 8
		for i := 0; i < arrayLength; i++ {
			elem, read, err := parseMorxChain(src[offset:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Morx: %s", err)
			}
			item.chains = append(item.chains, elem)
			offset += read
		}
		n = offset
	}
	return item, n, nil
}

func ParseMorxChainSubtable(src []byte, valuesCount int) (MorxChainSubtable, int, error) {
	var item MorxChainSubtable
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading MorxChainSubtable: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.length = binary.BigEndian.Uint32(src[0:])
	item.coverage = src[4]
	item.ignored[0] = src[5]
	item.ignored[1] = src[6]
	item.version = morxSubtableVersion(src[7])
	item.subFeatureFlags = binary.BigEndian.Uint32(src[8:])
	n += 12

	{
		var (
			read int
			err  error
		)
		switch item.version {
		case morxSubtableVersionContextual:
			item.subtableContent, read, err = parseMorxSubtableContextual(src[12:])
		case morxSubtableVersionInsertion:
			item.subtableContent, read, err = parseMorxSubtableInsertion(src[12:])
		case morxSubtableVersionLigature:
			item.subtableContent, read, err = parseMorxSubtableLigature(src[12:])
		case morxSubtableVersionNonContextual:
			item.subtableContent, read, err = parseMorxSubtableNonContextual(src[12:], valuesCount)
		case morxSubtableVersionRearrangement:
			item.subtableContent, read, err = parseMorxSubtableRearrangement(src[12:])
		default:
			err = fmt.Errorf("unsupported morxSubtableVersion %d", item.version)
		}
		if err != nil {
			return item, 0, fmt.Errorf("reading MorxChainSubtable: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func (item *aatFeature) mustParse(src []byte) {
	_ = src[11] // early bound checking
	item.featureType = binary.BigEndian.Uint16(src[0:])
	item.featureSetting = binary.BigEndian.Uint16(src[2:])
	item.enableFlags = binary.BigEndian.Uint32(src[4:])
	item.disableFlags = binary.BigEndian.Uint32(src[8:])
}

func (item *aatSTXHeader) mustParse(src []byte) {
	_ = src[15] // early bound checking
	item.stateSize = binary.BigEndian.Uint32(src[0:])
	item.classTable = binary.BigEndian.Uint32(src[4:])
	item.stateArray = binary.BigEndian.Uint32(src[8:])
	item.entryTable = binary.BigEndian.Uint32(src[12:])
}

func parseMorxChain(src []byte) (morxChain, int, error) {
	var item morxChain
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading morxChain: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.flags = binary.BigEndian.Uint32(src[0:])
	item.chainLength = binary.BigEndian.Uint32(src[4:])
	item.nFeatureEntries = binary.BigEndian.Uint32(src[8:])
	item.nSubtable = binary.BigEndian.Uint32(src[12:])
	n += 16

	{
		arrayLength := int(item.nFeatureEntries)

		if L := len(src); L < 16+arrayLength*12 {
			return item, 0, fmt.Errorf("reading morxChain: "+"EOF: expected length: %d, got %d", 16+arrayLength*12, L)
		}

		item.features = make([]aatFeature, arrayLength) // allocation guarded by the previous check
		for i := range item.features {
			item.features[i].mustParse(src[16+i*12:])
		}
		n += arrayLength * 12
	}
	{

		L := int(item.chainLength)
		if len(src) < L {
			return item, 0, fmt.Errorf("reading morxChain: "+"EOF: expected length: %d, got %d", L, len(src))
		}
		item.subtablesData = src[n:L]
		n = L
	}
	return item, n, nil
}

func parseMorxSubtableContextual(src []byte) (morxSubtableContextual, int, error) {
	var item morxSubtableContextual
	n := 0
	if L := len(src); L < 20 {
		return item, 0, fmt.Errorf("reading morxSubtableContextual: "+"EOF: expected length: 20, got %d", L)
	}
	_ = src[19] // early bound checking
	item.aatSTXHeader.mustParse(src[0:])
	item.substitutionTableOffset = binary.BigEndian.Uint32(src[16:])
	n += 20

	{

		item.rawData = src[20:]
		n = len(src)
	}
	return item, n, nil
}

func parseMorxSubtableInsertion(src []byte) (morxSubtableInsertion, int, error) {
	var item morxSubtableInsertion
	n := 0
	if L := len(src); L < 20 {
		return item, 0, fmt.Errorf("reading morxSubtableInsertion: "+"EOF: expected length: 20, got %d", L)
	}
	_ = src[19] // early bound checking
	item.aatSTXHeader.mustParse(src[0:])
	item.insertionActionOffset = binary.BigEndian.Uint32(src[16:])
	n += 20

	{

		item.rawData = src[20:]
		n = len(src)
	}
	return item, n, nil
}

func parseMorxSubtableLigature(src []byte) (morxSubtableLigature, int, error) {
	var item morxSubtableLigature
	n := 0
	if L := len(src); L < 28 {
		return item, 0, fmt.Errorf("reading morxSubtableLigature: "+"EOF: expected length: 28, got %d", L)
	}
	_ = src[27] // early bound checking
	item.aatSTXHeader.mustParse(src[0:])
	item.ligActionOffset = binary.BigEndian.Uint32(src[16:])
	item.componentOffset = binary.BigEndian.Uint32(src[20:])
	item.ligatureOffset = binary.BigEndian.Uint32(src[24:])
	n += 28

	{

		item.rawData = src[28:]
		n = len(src)
	}
	return item, n, nil
}

func parseMorxSubtableNonContextual(src []byte, valuesCount int) (morxSubtableNonContextual, int, error) {
	var item morxSubtableNonContextual
	n := 0
	{
		var (
			err  error
			read int
		)
		item.table, read, err = ParseAATLookup(src[0:], valuesCount)
		if err != nil {
			return item, 0, fmt.Errorf("reading morxSubtableNonContextual: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func parseMorxSubtableRearrangement(src []byte) (morxSubtableRearrangement, int, error) {
	var item morxSubtableRearrangement
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading morxSubtableRearrangement: "+"EOF: expected length: 16, got %d", L)
	}
	item.aatSTXHeader.mustParse(src[0:])
	n += 16

	{

		item.rawData = src[16:]
		n = len(src)
	}
	return item, n, nil
}
