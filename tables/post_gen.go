package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from post_src.go. DO NOT EDIT

func ParsePost(src []byte) (Post, int, error) {
	var item Post
	n := 0
	if L := len(src); L < 32 {
		return item, 0, fmt.Errorf("reading Post: "+"EOF: expected length: 32, got %d", L)
	}
	_ = src[31] // early bound checking
	item.version = postVersion(binary.BigEndian.Uint32(src[0:]))
	item.italicAngle = binary.BigEndian.Uint32(src[4:])
	item.underlinePosition = int16(binary.BigEndian.Uint16(src[8:]))
	item.underlineThickness = int16(binary.BigEndian.Uint16(src[10:]))
	item.isFixedPitch = binary.BigEndian.Uint32(src[12:])
	item.memoryUsage[0] = binary.BigEndian.Uint32(src[16:])
	item.memoryUsage[1] = binary.BigEndian.Uint32(src[20:])
	item.memoryUsage[2] = binary.BigEndian.Uint32(src[24:])
	item.memoryUsage[3] = binary.BigEndian.Uint32(src[28:])
	n += 32

	{
		var (
			read int
			err  error
		)
		switch item.version {
		case postVersion10:
			item.names, read, err = parsePostNames10(src[32:])
		case postVersion20:
			item.names, read, err = parsePostNames20(src[32:])
		case postVersion30:
			item.names, read, err = parsePostNames30(src[32:])
		default:
			err = fmt.Errorf("unsupported postNamesVersion %d", item.version)
		}
		if err != nil {
			return item, 0, fmt.Errorf("reading Post: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func parsePostNames10([]byte) (postNames10, int, error) {
	var item postNames10
	n := 0
	return item, n, nil
}

func parsePostNames20(src []byte) (postNames20, int, error) {
	var item postNames20
	n := 0
	if L := len(src); L < 2 {
		return item, 0, fmt.Errorf("reading postNames20: "+"EOF: expected length: 2, got %d", L)
	}
	arrayLengthItemglyphNameIndexes := int(binary.BigEndian.Uint16(src[0:]))
	n += 2

	{

		if L := len(src); L < 2+arrayLengthItemglyphNameIndexes*2 {
			return item, 0, fmt.Errorf("reading postNames20: "+"EOF: expected length: %d, got %d", 2+arrayLengthItemglyphNameIndexes*2, L)
		}

		item.glyphNameIndexes = make([]uint16, arrayLengthItemglyphNameIndexes) // allocation guarded by the previous check
		for i := range item.glyphNameIndexes {
			item.glyphNameIndexes[i] = binary.BigEndian.Uint16(src[2+i*2:])
		}
		n += arrayLengthItemglyphNameIndexes * 2
	}
	{

		item.stringData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

func parsePostNames30([]byte) (postNames30, int, error) {
	var item postNames30
	n := 0
	return item, n, nil
}
