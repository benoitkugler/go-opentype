package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from post.go. DO NOT EDIT

func ParsePost(src []byte) (Post, int, error) {
	var item Post
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 32 {
			return Post{}, 0, fmt.Errorf("EOF: expected length: 32, got %d", L)
		}

		_ = subSlice[31] // early bound checking
		item.version = postVersion(binary.BigEndian.Uint32(subSlice[0:]))
		item.italicAngle = binary.BigEndian.Uint32(subSlice[4:])
		item.underlinePosition = int16(binary.BigEndian.Uint16(subSlice[8:]))
		item.underlineThickness = int16(binary.BigEndian.Uint16(subSlice[10:]))
		item.isFixedPitch = binary.BigEndian.Uint32(subSlice[12:])
		for i := range item.memoryUsage {
			item.memoryUsage[i] = binary.BigEndian.Uint32(subSlice[16+i*4:])
		}
		n += 32

	}
	{
		var read int
		var err error
		switch item.version {
		case postVersion10:
			item.names, read, err = parsePostNames10(src[n:])
		case postVersion20:
			item.names, read, err = parsePostNames20(src[n:])
		case postVersion30:
			item.names, read, err = parsePostNames30(src[n:])
		default:
			err = fmt.Errorf("unsupported postNamesVersion %d", item.version)
		}
		if err != nil {
			return Post{}, 0, err
		}
		n += read
	}
	return item, n, nil
}
func parsePostNames10([]byte) (postNames10, int, error) {
	var item postNames10
	n := 0
	return item, n, nil
}
func parsePostNames20(src []byte) (postNames20, int, error) {
	var item postNames20
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return postNames20{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2, L)
		}
		arrayLength := int(binary.BigEndian.Uint16(subSlice[:]))
		if L := len(subSlice); L < 2+arrayLength*2 {
			return postNames20{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.glyphNameIndexes = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.glyphNameIndexes {
			item.glyphNameIndexes[i] = binary.BigEndian.Uint16(subSlice[2+i*2:])
		}

		n += 2 + arrayLength*2
	}
	item.stringData = src[n:]
	n = len(src)

	return item, n, nil
}
func parsePostNames30([]byte) (postNames30, int, error) {
	var item postNames30
	n := 0
	return item, n, nil
}
