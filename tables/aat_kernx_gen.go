package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from aat_kernx.go. DO NOT EDIT

func ParseKerx(src []byte) (Kerx, int, error) {
	var item Kerx
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 8 {
			return Kerx{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
		}

		_ = subSlice[7] // early bound checking
		item.version = binary.BigEndian.Uint16(subSlice[0:])
		item.padding = binary.BigEndian.Uint16(subSlice[2:])
		item.nTables = binary.BigEndian.Uint32(subSlice[4:])
		n += 8

	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}
func (item *aatSTHeader) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.stateSize = binary.BigEndian.Uint16(src[0:])
	item.classTable = binary.BigEndian.Uint16(src[2:])
	item.stateArray = binary.BigEndian.Uint16(src[4:])
	item.entryTable = binary.BigEndian.Uint16(src[6:])
}
func parseAatSTHeader(src []byte) (aatSTHeader, int, error) {
	var item aatSTHeader
	n := 0
	if L := len(src); L < 8 {
		return aatSTHeader{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
	}

	item.mustParse(src)
	n += 8
	return item, n, nil
}
func parseKernSubtable0(src []byte) (kernSubtable0, int, error) {
	var item kernSubtable0
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 8 {
			return kernSubtable0{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
		}

		_ = subSlice[7] // early bound checking
		item.nPairs = binary.BigEndian.Uint16(subSlice[0:])
		item.searchRange = binary.BigEndian.Uint16(subSlice[2:])
		item.entrySelector = binary.BigEndian.Uint16(subSlice[4:])
		item.rangeShift = binary.BigEndian.Uint16(subSlice[6:])
		n += 8

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nPairs)
		if L := len(subSlice); L < +arrayLength*6 {
			return kernSubtable0{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*6, L)
		}

		item.pairs = make([]kernx0Record, arrayLength) // allocation guarded by the previous check
		for i := range item.pairs {
			item.pairs[i].mustParse(subSlice[+i*6:])
		}

		n += arrayLength * 6
	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}
func parseKernSubtable1(src []byte) (kernSubtable1, int, error) {
	var item kernSubtable1
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return kernSubtable1{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.aatSTHeader.mustParse(subSlice[0:])
		item.valueTable = binary.BigEndian.Uint16(subSlice[8:])
		n += 10

	}
	item.rawData = src
	n = len(src)

	return item, n, nil
}
func parseKernSubtable2(src []byte) (kernSubtable2, int, error) {
	var item kernSubtable2
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 8 {
			return kernSubtable2{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
		}

		_ = subSlice[7] // early bound checking
		item.rowWidth = binary.BigEndian.Uint16(subSlice[0:])
		offsetToLeft := int(binary.BigEndian.Uint16(subSlice[2:]))
		offsetToRight := int(binary.BigEndian.Uint16(subSlice[4:]))
		item.kerningArrayOffset = binary.BigEndian.Uint16(subSlice[6:])
		n += 8
		if L := len(src); L < offsetToLeft {
			return kernSubtable2{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", offsetToLeft, L)
		}

		{
			var read int
			var err error
			item.left, read, err = parseAatLookupTable8(src[offsetToLeft:])
			if err != nil {
				return kernSubtable2{}, 0, err
			}
			offsetToLeft += read
		}
		if L := len(src); L < offsetToRight {
			return kernSubtable2{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", offsetToRight, L)
		}

		{
			var read int
			var err error
			item.right, read, err = parseAatLookupTable8(src[offsetToRight:])
			if err != nil {
				return kernSubtable2{}, 0, err
			}
			offsetToRight += read
		}
	}
	item.rawData = src
	n = len(src)

	return item, n, nil
}
func parseKernSubtableW(src []byte) (kernSubtableW, int, error) {
	var item kernSubtableW
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 8 {
			return kernSubtableW{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
		}

		_ = subSlice[7] // early bound checking
		item.length = binary.BigEndian.Uint32(subSlice[0:])
		item.coverage = subSlice[4]
		item.version = kernSTVersion(subSlice[5])
		item.tupleCount = binary.BigEndian.Uint16(subSlice[6:])
		n += 8

	}
	{
		var read int
		var err error
		switch item.version {

		default:
			err = fmt.Errorf("unsupported kernSubtableVersion %d", item.version)
		}
		if err != nil {
			return kernSubtableW{}, 0, err
		}
		n += read
	}
	return item, n, nil
}
func (item *kernx0Record) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.left = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.right = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.value = int16(binary.BigEndian.Uint16(src[4:]))
}
func parseKernx0Record(src []byte) (kernx0Record, int, error) {
	var item kernx0Record
	n := 0
	if L := len(src); L < 6 {
		return kernx0Record{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
	}

	item.mustParse(src)
	n += 6
	return item, n, nil
}
func parseKerxSubtable0(src []byte) (kerxSubtable0, int, error) {
	var item kerxSubtable0
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 16 {
			return kerxSubtable0{}, 0, fmt.Errorf("EOF: expected length: 16, got %d", L)
		}

		_ = subSlice[15] // early bound checking
		item.nPairs = binary.BigEndian.Uint32(subSlice[0:])
		item.searchRange = binary.BigEndian.Uint32(subSlice[4:])
		item.entrySelector = binary.BigEndian.Uint32(subSlice[8:])
		item.rangeShift = binary.BigEndian.Uint32(subSlice[12:])
		n += 16

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nPairs)
		if L := len(subSlice); L < +arrayLength*6 {
			return kerxSubtable0{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*6, L)
		}

		item.pairs = make([]kernx0Record, arrayLength) // allocation guarded by the previous check
		for i := range item.pairs {
			item.pairs[i].mustParse(subSlice[+i*6:])
		}

		n += arrayLength * 6
	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}
func parseKerxSubtableW(src []byte) (kerxSubtableW, int, error) {
	var item kerxSubtableW
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 12 {
			return kerxSubtableW{}, 0, fmt.Errorf("EOF: expected length: 12, got %d", L)
		}

		_ = subSlice[11] // early bound checking
		item.length = binary.BigEndian.Uint32(subSlice[0:])
		item.coverage = binary.BigEndian.Uint16(subSlice[4:])
		item.padding = subSlice[6]
		item.version = kerxSTVersion(subSlice[7])
		item.tupleCount = binary.BigEndian.Uint32(subSlice[8:])
		n += 12

	}
	{
		var read int
		var err error
		switch item.version {

		default:
			err = fmt.Errorf("unsupported kerxSubtableVersion %d", item.version)
		}
		if err != nil {
			return kerxSubtableW{}, 0, err
		}
		n += read
	}
	return item, n, nil
}
