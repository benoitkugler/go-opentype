package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from aat_kernx_src.go. DO NOT EDIT

func (item *Kernx0Record) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.Left = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.Right = GlyphID(binary.BigEndian.Uint16(src[2:]))
	item.value = int16(binary.BigEndian.Uint16(src[4:]))
}

func ParseAATStateTableExt(src []byte, valuesCount int, entryDataSize int) (AATStateTableExt, int, error) {
	var item AATStateTableExt
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading AATStateTableExt: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.stateSize = binary.BigEndian.Uint32(src[0:])
	offsetClass := int(binary.BigEndian.Uint32(src[4:]))
	item.stateArray = Offset32(binary.BigEndian.Uint32(src[8:]))
	item.entryTable = Offset32(binary.BigEndian.Uint32(src[12:]))
	n += 16

	{

		if offsetClass != 0 { // ignore null offset
			if L := len(src); L < offsetClass {
				return item, 0, fmt.Errorf("reading AATStateTableExt: "+"EOF: expected length: %d, got %d", offsetClass, L)
			}

			var (
				err  error
				read int
			)
			item.Class, read, err = ParseAATLookup(src[offsetClass:], valuesCount)
			if err != nil {
				return item, 0, fmt.Errorf("reading AATStateTableExt: %s", err)
			}
			offsetClass += read
		}
	}
	{

		read, err := item.parseStates(src[:], valuesCount, entryDataSize)
		if err != nil {
			return item, 0, fmt.Errorf("reading AATStateTableExt: %s", err)
		}
		n = read
	}
	{

		read, err := item.parseEntries(src[:], valuesCount, entryDataSize)
		if err != nil {
			return item, 0, fmt.Errorf("reading AATStateTableExt: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseKerx(src []byte, valuesCount int) (Kerx, int, error) {
	var item Kerx
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading Kerx: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.version = binary.BigEndian.Uint16(src[0:])
	item.padding = binary.BigEndian.Uint16(src[2:])
	item.nTables = binary.BigEndian.Uint32(src[4:])
	n += 8

	{
		arrayLength := int(item.nTables)

		offset := 8
		for i := 0; i < arrayLength; i++ {
			elem, read, err := ParseKerxSubtable(src[offset:], valuesCount)
			if err != nil {
				return item, 0, fmt.Errorf("reading Kerx: %s", err)
			}
			item.Tables = append(item.Tables, elem)
			offset += read
		}
		n = offset
	}
	return item, n, nil
}

func ParseKerxData0(src []byte) (KerxData0, int, error) {
	var item KerxData0
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading KerxData0: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.nPairs = binary.BigEndian.Uint32(src[0:])
	item.searchRange = binary.BigEndian.Uint32(src[4:])
	item.entrySelector = binary.BigEndian.Uint32(src[8:])
	item.rangeShift = binary.BigEndian.Uint32(src[12:])
	n += 16

	{
		arrayLength := int(item.nPairs)

		if L := len(src); L < 16+arrayLength*6 {
			return item, 0, fmt.Errorf("reading KerxData0: "+"EOF: expected length: %d, got %d", 16+arrayLength*6, L)
		}

		item.Pairs = make([]Kernx0Record, arrayLength) // allocation guarded by the previous check
		for i := range item.Pairs {
			item.Pairs[i].mustParse(src[16+i*6:])
		}
		n += arrayLength * 6
	}
	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseKerxData1(src []byte, tupleCount int, valuesCount int) (KerxData1, int, error) {
	var item KerxData1
	n := 0
	{
		var (
			err  error
			read int
		)
		item.AATStateTableExt, read, err = ParseAATStateTableExt(src[0:], int(valuesCount), int(2))
		if err != nil {
			return item, 0, fmt.Errorf("reading KerxData1: %s", err)
		}
		n += read
	}
	if L := len(src); L < n+4 {
		return item, 0, fmt.Errorf("reading KerxData1: "+"EOF: expected length: n + 4, got %d", L)
	}
	item.valueTable = Offset32(binary.BigEndian.Uint32(src[n:]))
	n += 4

	{

		read, err := item.parseValues(src[:], tupleCount, valuesCount)
		if err != nil {
			return item, 0, fmt.Errorf("reading KerxData1: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseKerxData2(src []byte, parentSrc []byte, valuesCount int) (KerxData2, int, error) {
	var item KerxData2
	n := 0
	if L := len(src); L < 16 {
		return item, 0, fmt.Errorf("reading KerxData2: "+"EOF: expected length: 16, got %d", L)
	}
	_ = src[15] // early bound checking
	item.rowWidth = binary.BigEndian.Uint32(src[0:])
	offsetLeft := int(binary.BigEndian.Uint32(src[4:]))
	offsetRight := int(binary.BigEndian.Uint32(src[8:]))
	item.array = Offset32(binary.BigEndian.Uint32(src[12:]))
	n += 16

	{

		if offsetLeft != 0 { // ignore null offset
			if L := len(parentSrc); L < offsetLeft {
				return item, 0, fmt.Errorf("reading KerxData2: "+"EOF: expected length: %d, got %d", offsetLeft, L)
			}

			var (
				err  error
				read int
			)
			item.Left, read, err = ParseAATLookup(parentSrc[offsetLeft:], valuesCount)
			if err != nil {
				return item, 0, fmt.Errorf("reading KerxData2: %s", err)
			}
			offsetLeft += read
		}
	}
	{

		if offsetRight != 0 { // ignore null offset
			if L := len(parentSrc); L < offsetRight {
				return item, 0, fmt.Errorf("reading KerxData2: "+"EOF: expected length: %d, got %d", offsetRight, L)
			}

			var (
				err  error
				read int
			)
			item.Right, read, err = ParseAATLookup(parentSrc[offsetRight:], valuesCount)
			if err != nil {
				return item, 0, fmt.Errorf("reading KerxData2: %s", err)
			}
			offsetRight += read
		}
	}
	{

		item.kerningData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseKerxData4([]byte) (KerxData4, int, error) {
	var item KerxData4
	n := 0
	return item, n, nil
}

func ParseKerxData6([]byte) (KerxData6, int, error) {
	var item KerxData6
	n := 0
	return item, n, nil
}

func ParseKerxSubtable(src []byte, valuesCount int) (KerxSubtable, int, error) {
	var item KerxSubtable
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading KerxSubtable: "+"EOF: expected length: 12, got %d", L)
	}
	_ = src[11] // early bound checking
	item.length = binary.BigEndian.Uint32(src[0:])
	item.Coverage = binary.BigEndian.Uint16(src[4:])
	item.padding = src[6]
	item.version = kerxSTVersion(src[7])
	item.TupleCount = binary.BigEndian.Uint32(src[8:])
	n += 12

	{
		var (
			read int
			err  error
		)
		switch item.version {
		case kerxSTVersion0:
			item.Data, read, err = ParseKerxData0(src[12:])
		case kerxSTVersion1:
			item.Data, read, err = ParseKerxData1(src[12:], int(item.TupleCount), int(valuesCount))
		case kerxSTVersion2:
			item.Data, read, err = ParseKerxData2(src[12:], src, int(valuesCount))
		case kerxSTVersion4:
			item.Data, read, err = ParseKerxData4(src[12:])
		case kerxSTVersion6:
			item.Data, read, err = ParseKerxData6(src[12:])
		default:
			err = fmt.Errorf("unsupported KerxDataVersion %d", item.version)
		}
		if err != nil {
			return item, 0, fmt.Errorf("reading KerxSubtable: %s", err)
		}
		n += read
	}
	var err error
	n, err = item.parseEnd(src)
	if err != nil {
		return item, 0, fmt.Errorf("reading KerxSubtable: %s", err)
	}

	return item, n, nil
}

func (item *aatSTHeader) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.stateSize = binary.BigEndian.Uint16(src[0:])
	item.classTable = binary.BigEndian.Uint16(src[2:])
	item.stateArray = binary.BigEndian.Uint16(src[4:])
	item.entryTable = binary.BigEndian.Uint16(src[6:])
}

func (item *microsoftKern) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.version = binary.BigEndian.Uint16(src[0:])
	item.nTables = binary.BigEndian.Uint16(src[2:])
}

func parseKernSubtable0(src []byte) (kernSubtable0, int, error) {
	var item kernSubtable0
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading kernSubtable0: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.nPairs = binary.BigEndian.Uint16(src[0:])
	item.searchRange = binary.BigEndian.Uint16(src[2:])
	item.entrySelector = binary.BigEndian.Uint16(src[4:])
	item.rangeShift = binary.BigEndian.Uint16(src[6:])
	n += 8

	{
		arrayLength := int(item.nPairs)

		if L := len(src); L < 8+arrayLength*6 {
			return item, 0, fmt.Errorf("reading kernSubtable0: "+"EOF: expected length: %d, got %d", 8+arrayLength*6, L)
		}

		item.pairs = make([]Kernx0Record, arrayLength) // allocation guarded by the previous check
		for i := range item.pairs {
			item.pairs[i].mustParse(src[8+i*6:])
		}
		n += arrayLength * 6
	}
	{

		item.rawData = src[n:]
		n = len(src)
	}
	return item, n, nil
}

func parseKernSubtable1(src []byte) (kernSubtable1, int, error) {
	var item kernSubtable1
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading kernSubtable1: "+"EOF: expected length: 10, got %d", L)
	}
	_ = src[9] // early bound checking
	item.aatSTHeader.mustParse(src[0:])
	item.valueTable = binary.BigEndian.Uint16(src[8:])
	n += 10

	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func parseKernSubtable2(src []byte) (kernSubtable2, int, error) {
	var item kernSubtable2
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading kernSubtable2: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.rowWidth = binary.BigEndian.Uint16(src[0:])
	offsetLeft := int(binary.BigEndian.Uint16(src[2:]))
	offsetRight := int(binary.BigEndian.Uint16(src[4:]))
	item.kerningArrayOffset = binary.BigEndian.Uint16(src[6:])
	n += 8

	{

		if offsetLeft != 0 { // ignore null offset
			if L := len(src); L < offsetLeft {
				return item, 0, fmt.Errorf("reading kernSubtable2: "+"EOF: expected length: %d, got %d", offsetLeft, L)
			}

			var (
				err  error
				read int
			)
			item.left, read, err = ParseAATLoopkup8(src[offsetLeft:])
			if err != nil {
				return item, 0, fmt.Errorf("reading kernSubtable2: %s", err)
			}
			offsetLeft += read

		}
	}
	{

		if offsetRight != 0 { // ignore null offset
			if L := len(src); L < offsetRight {
				return item, 0, fmt.Errorf("reading kernSubtable2: "+"EOF: expected length: %d, got %d", offsetRight, L)
			}

			var (
				err  error
				read int
			)
			item.right, read, err = ParseAATLoopkup8(src[offsetRight:])
			if err != nil {
				return item, 0, fmt.Errorf("reading kernSubtable2: %s", err)
			}
			offsetRight += read

		}
	}
	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}
