package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from name.go. DO NOT EDIT

func ParseName(src []byte) (Name, int, error) {
	var item Name
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 6 {
			return Name{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
		}

		_ = subSlice[5] // early bound checking
		item.version = binary.BigEndian.Uint16(subSlice[0:])
		item.count = binary.BigEndian.Uint16(subSlice[2:])
		offsetToStringData := int(binary.BigEndian.Uint16(subSlice[4:]))
		n += 6
		if L := len(src); L < offsetToStringData {
			return Name{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", offsetToStringData, L)
		}

		item.stringData = src[offsetToStringData:]
		offsetToStringData = len(src)

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.count)
		if L := len(subSlice); L < +arrayLength*12 {
			return Name{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*12, L)
		}

		item.nameRecords = make([]nameRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.nameRecords {
			item.nameRecords[i].mustParse(subSlice[+i*12:])
		}

		n += arrayLength * 12
	}
	return item, n, nil
}
func (item *nameRecord) mustParse(src []byte) {
	_ = src[11] // early bound checking
	item.platformID = PlatformID(binary.BigEndian.Uint16(src[0:]))
	item.encodingID = EncodingID(binary.BigEndian.Uint16(src[2:]))
	item.languageID = LanguageID(binary.BigEndian.Uint16(src[4:]))
	item.nameID = NameID(binary.BigEndian.Uint16(src[6:]))
	item.length = binary.BigEndian.Uint16(src[8:])
	item.stringOffset = binary.BigEndian.Uint16(src[10:])
}
func parseNameRecord(src []byte) (nameRecord, int, error) {
	var item nameRecord
	n := 0
	if L := len(src); L < 12 {
		return nameRecord{}, 0, fmt.Errorf("EOF: expected length: 12, got %d", L)
	}

	item.mustParse(src)
	n += 12
	return item, n, nil
}
