package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from maxp.go. DO NOT EDIT

func ParseMaxp(src []byte) (Maxp, int, error) {
	var item Maxp
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 6 {
			return Maxp{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
		}

		_ = subSlice[5] // early bound checking
		item.version = maxpVersion(binary.BigEndian.Uint32(subSlice[0:]))
		item.numGlyphs = binary.BigEndian.Uint16(subSlice[4:])
		n += 6

	}
	{
		var read int
		var err error
		switch item.version {
		case maxpVersion05:
			item.data, read, err = parseMaxpData05(src[n:])
		case maxpVersion1:
			item.data, read, err = parseMaxpData1(src[n:])
		default:
			err = fmt.Errorf("unsupported maxpDataVersion %d", item.version)
		}
		if err != nil {
			return Maxp{}, 0, err
		}
		n += read
	}
	return item, n, nil
}

func parseMaxpData05([]byte) (maxpData05, int, error) {
	var item maxpData05
	n := 0
	return item, n, nil
}

func (item *maxpData1) mustParse(src []byte) {
	_ = src[25] // early bound checking
	for i := range item.rawData {
		item.rawData[i] = binary.BigEndian.Uint16(src[i*2:])
	}
}

func parseMaxpData1(src []byte) (maxpData1, int, error) {
	var item maxpData1
	n := 0
	if L := len(src); L < 26 {
		return maxpData1{}, 0, fmt.Errorf("EOF: expected length: 26, got %d", L)
	}

	item.mustParse(src)
	n += 26
	return item, n, nil
}
