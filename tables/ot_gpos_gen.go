package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from ot_gpos_src.go. DO NOT EDIT

func (item *DeviceTableHeader) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.first = binary.BigEndian.Uint16(src[0:])
	item.second = binary.BigEndian.Uint16(src[2:])
	item.deltaFormat = binary.BigEndian.Uint16(src[4:])
}

func ParseClassDef(src []byte) (ClassDef, int, error) {
	var item ClassDef
	n := 0
	{
		if L := len(src); L < 2 {
			return ClassDef{}, 0, fmt.Errorf("reading ClassDef: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = classDefVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case classDefVersion1:
			item.data, read, err = parseClassDefData1(src[2:])
		case classDefVersion2:
			item.data, read, err = parseClassDefData2(src[2:])
		default:
			err = fmt.Errorf("unsupported classDefDataVersion %d", item.format)
		}
		if err != nil {
			return ClassDef{}, 0, fmt.Errorf("reading ClassDef: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseCoverage(src []byte) (Coverage, int, error) {
	var item Coverage
	n := 0
	{
		if L := len(src); L < 2 {
			return Coverage{}, 0, fmt.Errorf("reading Coverage: "+"EOF: expected length: 2, got %d", L)
		}
		item.format = coverageVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.format {
		case coverageVersion1:
			item.data, read, err = parseCoverageData1(src[2:])
		case coverageVersion2:
			item.data, read, err = parseCoverageData2(src[2:])
		default:
			err = fmt.Errorf("unsupported coverageDataVersion %d", item.format)
		}
		if err != nil {
			return Coverage{}, 0, fmt.Errorf("reading Coverage: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseDeviceTableHeader(src []byte) (DeviceTableHeader, int, error) {
	var item DeviceTableHeader
	n := 0
	if L := len(src); L < 6 {
		return DeviceTableHeader{}, 0, fmt.Errorf("reading DeviceTableHeader: "+"EOF: expected length: 6, got %d", L)
	}
	item.mustParse(src)
	n += 6
	return item, n, nil
}

func ParsePairPos(src []byte) (PairPos, int, error) {
	var item PairPos
	n := 0
	{
		if L := len(src); L < 2 {
			return PairPos{}, 0, fmt.Errorf("reading PairPos: "+"EOF: expected length: 2, got %d", L)
		}
		item.posFormat = pairPosVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.posFormat {
		case pairPosVersion1:
			item.Data, read, err = ParsePairPosData1(src[:])
		case pairPosVersion2:
			item.Data, read, err = ParsePairPosData2(src[:])
		default:
			err = fmt.Errorf("unsupported PairPosDataVersion %d", item.posFormat)
		}
		if err != nil {
			return PairPos{}, 0, fmt.Errorf("reading PairPos: %s", err)
		}
		n = read
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParsePairPosData1(src []byte) (PairPosData1, int, error) {
	var item PairPosData1
	n := 2
	{
		if L := len(src); L < 4 {
			return PairPosData1{}, 0, fmt.Errorf("reading PairPosData1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return PairPosData1{}, 0, fmt.Errorf("reading PairPosData1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return PairPosData1{}, 0, fmt.Errorf("reading PairPosData1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return PairPosData1{}, 0, fmt.Errorf("reading PairPosData1: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[7] // early bound checking
		item.valueFormat1 = ValueFormat(binary.BigEndian.Uint16(src[4:]))
		item.valueFormat2 = ValueFormat(binary.BigEndian.Uint16(src[6:]))
		n += 4
	}
	{
		if L := len(src); L < 10 {
			return PairPosData1{}, 0, fmt.Errorf("reading PairPosData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[8:]))
		n += 2

		if L := len(src); L < 10+arrayLength*2 {
			return PairPosData1{}, 0, fmt.Errorf("reading PairPosData1: "+"EOF: expected length: %d, got %d", 10+arrayLength*2, L)
		}

		item.PairSetOffset = make([]PairSet, arrayLength) // allocation guarded by the previous check
		for i := range item.PairSetOffset {
			offset := int(binary.BigEndian.Uint16(src[10+i*2:]))
			// ignore null offsets
			if offset == 0 {
				continue
			}

			if L := len(src); L < offset {
				return PairPosData1{}, 0, fmt.Errorf("reading PairPosData1: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var err error
			item.PairSetOffset[i], _, err = ParsePairSet(src[offset:], ValueFormat(item.valueFormat1), ValueFormat(item.valueFormat2))
			if err != nil {
				return PairPosData1{}, 0, fmt.Errorf("reading PairPosData1: %s", err)
			}

		}
		n += arrayLength * 2
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParsePairPosData2(src []byte) (PairPosData2, int, error) {
	var item PairPosData2
	n := 2
	{
		if L := len(src); L < 4 {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[7] // early bound checking
		item.valueFormat1 = ValueFormat(binary.BigEndian.Uint16(src[4:]))
		item.valueFormat2 = ValueFormat(binary.BigEndian.Uint16(src[6:]))
		n += 4
	}
	{
		if L := len(src); L < 10 {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[8:]))
		n += 2
		if L := len(src); L < offset {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.classDef1, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 12 {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[10:]))
		n += 2
		if L := len(src); L < offset {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.classDef2, read, err = ParseClassDef(src[offset:])
		if err != nil {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 16 {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[15] // early bound checking
		item.class1Count = binary.BigEndian.Uint16(src[12:])
		item.class2Count = binary.BigEndian.Uint16(src[14:])
		n += 4
	}
	{

		read, err := item.customParseClass1Records(src[:])
		if err != nil {
			return PairPosData2{}, 0, fmt.Errorf("reading PairPosData2: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParsePairSet(src []byte, valueFormat1 ValueFormat, valueFormat2 ValueFormat) (PairSet, int, error) {
	var item PairSet
	n := 0
	{
		if L := len(src); L < 2 {
			return PairSet{}, 0, fmt.Errorf("reading PairSet: "+"EOF: expected length: 2, got %d", L)
		}
		item.pairValueCount = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{

		read, err := item.customParsePairValueRecords(src[:], valueFormat1, valueFormat2)
		if err != nil {
			return PairSet{}, 0, fmt.Errorf("reading PairSet: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseSinglePos(src []byte) (SinglePos, int, error) {
	var item SinglePos
	n := 0
	{
		if L := len(src); L < 2 {
			return SinglePos{}, 0, fmt.Errorf("reading SinglePos: "+"EOF: expected length: 2, got %d", L)
		}
		item.posFormat = singlePosVersion(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		var (
			read int
			err  error
		)
		switch item.posFormat {
		case singlePosVersion1:
			item.Data, read, err = ParseSinglePosData1(src[:])
		case singlePosVersion2:
			item.Data, read, err = ParseSinglePosData2(src[:])
		default:
			err = fmt.Errorf("unsupported SinglePosDataVersion %d", item.posFormat)
		}
		if err != nil {
			return SinglePos{}, 0, fmt.Errorf("reading SinglePos: %s", err)
		}
		n = read
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseSinglePosData1(src []byte) (SinglePosData1, int, error) {
	var item SinglePosData1
	n := 2
	{
		if L := len(src); L < 4 {
			return SinglePosData1{}, 0, fmt.Errorf("reading SinglePosData1: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return SinglePosData1{}, 0, fmt.Errorf("reading SinglePosData1: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return SinglePosData1{}, 0, fmt.Errorf("reading SinglePosData1: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 6 {
			return SinglePosData1{}, 0, fmt.Errorf("reading SinglePosData1: "+"EOF: expected length: 2, got %d", L)
		}
		item.valueFormat = ValueFormat(binary.BigEndian.Uint16(src[4:]))
		n += 2
	}
	{

		read, err := item.customParseValueRecord(src[:])
		if err != nil {
			return SinglePosData1{}, 0, fmt.Errorf("reading SinglePosData1: %s", err)
		}
		n = read
	}
	return item, n, nil
}

// the actual data starts at src[2:]
func ParseSinglePosData2(src []byte) (SinglePosData2, int, error) {
	var item SinglePosData2
	n := 2
	{
		if L := len(src); L < 4 {
			return SinglePosData2{}, 0, fmt.Errorf("reading SinglePosData2: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[2:]))
		n += 2
		if L := len(src); L < offset {
			return SinglePosData2{}, 0, fmt.Errorf("reading SinglePosData2: "+"EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.Coverage, read, err = ParseCoverage(src[offset:])
		if err != nil {
			return SinglePosData2{}, 0, fmt.Errorf("reading SinglePosData2: %s", err)
		}
		offset += read
	}
	{
		if L := len(src); L < 8 {
			return SinglePosData2{}, 0, fmt.Errorf("reading SinglePosData2: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[7] // early bound checking
		item.valueFormat = ValueFormat(binary.BigEndian.Uint16(src[4:]))
		item.valueCount = binary.BigEndian.Uint16(src[6:])
		n += 4
	}
	{

		read, err := item.customParseValueRecords(src[:])
		if err != nil {
			return SinglePosData2{}, 0, fmt.Errorf("reading SinglePosData2: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func (item *classRangeRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.StartGlyphID = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.EndGlyphID = GlyphID(binary.BigEndian.Uint16(src[2:]))
	item.Class = binary.BigEndian.Uint16(src[4:])
}

func parseClassDefData1(src []byte) (classDefData1, int, error) {
	var item classDefData1
	n := 0
	{
		if L := len(src); L < 2 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: 2, got %d", L)
		}
		item.StartGlyphID = GlyphID(binary.BigEndian.Uint16(src[0:]))
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*2 {
			return classDefData1{}, 0, fmt.Errorf("reading classDefData1: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.ClassValueArray = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.ClassValueArray {
			item.ClassValueArray[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func parseClassDefData2(src []byte) (classDefData2, int, error) {
	var item classDefData2
	n := 0
	{
		if L := len(src); L < 2 {
			return classDefData2{}, 0, fmt.Errorf("reading classDefData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return classDefData2{}, 0, fmt.Errorf("reading classDefData2: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.ClassRangeRecords = make([]classRangeRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.ClassRangeRecords {
			item.ClassRangeRecords[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func parseCoverageData1(src []byte) (coverageData1, int, error) {
	var item coverageData1
	n := 0
	{
		if L := len(src); L < 2 {
			return coverageData1{}, 0, fmt.Errorf("reading coverageData1: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return coverageData1{}, 0, fmt.Errorf("reading coverageData1: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.Glyphs = make([]GlyphID, arrayLength) // allocation guarded by the previous check
		for i := range item.Glyphs {
			item.Glyphs[i] = GlyphID(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func parseCoverageData2(src []byte) (coverageData2, int, error) {
	var item coverageData2
	n := 0
	{
		if L := len(src); L < 2 {
			return coverageData2{}, 0, fmt.Errorf("reading coverageData2: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return coverageData2{}, 0, fmt.Errorf("reading coverageData2: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.Ranges = make([]rangeRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.Ranges {
			item.Ranges[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	return item, n, nil
}

func (item *rangeRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.StartGlyphID = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.EndGlyphID = GlyphID(binary.BigEndian.Uint16(src[2:]))
	item.StartCoverageIndex = binary.BigEndian.Uint16(src[4:])
}
