package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from hmtx_vmtx.go. DO NOT EDIT

func parseHtmx(src []byte, hmetricsLength int, leftsidebearingsLength int) (htmx, int, error) {
	var item htmx
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < +hmetricsLength*4 {
			return htmx{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +hmetricsLength*4, L)
		}

		item.hMetrics = make([]longHorMetric, hmetricsLength) // allocation guarded by the previous check
		for i := range item.hMetrics {
			item.hMetrics[i].mustParse(subSlice[i*4:])
		}

		n += hmetricsLength * 4
	}
	{
		subSlice := src[n:]
		if L := len(subSlice); L < +leftsidebearingsLength*2 {
			return htmx{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +leftsidebearingsLength*2, L)
		}

		item.leftSideBearings = make([]int16, leftsidebearingsLength) // allocation guarded by the previous check
		for i := range item.leftSideBearings {
			item.leftSideBearings[i] = int16(binary.BigEndian.Uint16(subSlice[i*2:]))
		}

		n += leftsidebearingsLength * 2
	}
	return item, n, nil
}

func (item *longHorMetric) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.advanceWidth = int16(binary.BigEndian.Uint16(src[0:]))
	item.lsb = int16(binary.BigEndian.Uint16(src[2:]))
}

func parseLongHorMetric(src []byte) (longHorMetric, int, error) {
	var item longHorMetric
	n := 0
	if L := len(src); L < 4 {
		return longHorMetric{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
	}

	item.mustParse(src)
	n += 4
	return item, n, nil
}
