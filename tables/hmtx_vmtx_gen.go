package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from hmtx_vmtx_src.go. DO NOT EDIT

func ParseHmtx(src []byte, hMetricsCount int, leftSideBearingsCount int) (Hmtx, int, error) {
	var item Hmtx
	n := 0
	{

		if L := len(src); L < hMetricsCount*4 {
			return item, 0, fmt.Errorf("reading Hmtx: "+"EOF: expected length: %d, got %d", hMetricsCount*4, L)
		}

		item.hMetrics = make([]longHorMetric, hMetricsCount) // allocation guarded by the previous check
		for i := range item.hMetrics {
			item.hMetrics[i].mustParse(src[i*4:])
		}
		n += hMetricsCount * 4
	}
	{

		if L := len(src); L < n+leftSideBearingsCount*2 {
			return item, 0, fmt.Errorf("reading Hmtx: "+"EOF: expected length: %d, got %d", n+leftSideBearingsCount*2, L)
		}

		item.leftSideBearings = make([]int16, leftSideBearingsCount) // allocation guarded by the previous check
		for i := range item.leftSideBearings {
			item.leftSideBearings[i] = int16(binary.BigEndian.Uint16(src[n+i*2:]))
		}
		n += leftSideBearingsCount * 2
	}
	return item, n, nil
}

func (item *longHorMetric) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.advanceWidth = int16(binary.BigEndian.Uint16(src[0:]))
	item.lsb = int16(binary.BigEndian.Uint16(src[2:]))
}
