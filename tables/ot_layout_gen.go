package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from ot_layout_src.go. DO NOT EDIT

func (item *FeatureVariationRecord) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.conditionSetOffset = binary.BigEndian.Uint32(src[0:])
	item.featureTableSubstitutionOffset = binary.BigEndian.Uint32(src[4:])
}

func ParseFeature(src []byte) (Feature, int, error) {
	var item Feature
	n := 0
	{
		if L := len(src); L < 2 {
			return item, 0, fmt.Errorf("reading Feature: "+"EOF: expected length: 2, got %d", L)
		}
		item.featureParamsOffset = binary.BigEndian.Uint16(src[0:])
		n += 2
	}
	{
		if L := len(src); L < 4 {
			return item, 0, fmt.Errorf("reading Feature: "+"EOF: expected length: 4, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*2 {
			return item, 0, fmt.Errorf("reading Feature: "+"EOF: expected length: %d, got %d", 4+arrayLength*2, L)
		}

		item.LookupListIndices = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.LookupListIndices {
			item.LookupListIndices[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseFeatureVariation(src []byte) (FeatureVariation, int, error) {
	var item FeatureVariation
	n := 0
	{
		if L := len(src); L < 4 {
			return item, 0, fmt.Errorf("reading FeatureVariation: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.majorVersion = binary.BigEndian.Uint16(src[0:])
		item.minorVersion = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		if L := len(src); L < 8 {
			return item, 0, fmt.Errorf("reading FeatureVariation: "+"EOF: expected length: 8, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint32(src[4:]))
		n += 4

		if L := len(src); L < 8+arrayLength*8 {
			return item, 0, fmt.Errorf("reading FeatureVariation: "+"EOF: expected length: %d, got %d", 8+arrayLength*8, L)
		}

		item.featureVariationRecords = make([]FeatureVariationRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.featureVariationRecords {
			item.featureVariationRecords[i].mustParse(src[8+i*8:])
		}
		n += arrayLength * 8
	}
	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseFeatureVariationRecord(src []byte) (FeatureVariationRecord, int, error) {
	var item FeatureVariationRecord
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading FeatureVariationRecord: "+"EOF: expected length: 8, got %d", L)
	}
	item.mustParse(src)
	n += 8
	return item, n, nil
}

func ParseLangSys(src []byte) (LangSys, int, error) {
	var item LangSys
	n := 0
	{
		if L := len(src); L < 4 {
			return item, 0, fmt.Errorf("reading LangSys: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.lookupOrderOffset = binary.BigEndian.Uint16(src[0:])
		item.RequiredFeatureIndex = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		if L := len(src); L < 6 {
			return item, 0, fmt.Errorf("reading LangSys: "+"EOF: expected length: 6, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return item, 0, fmt.Errorf("reading LangSys: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.FeatureIndices = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.FeatureIndices {
			item.FeatureIndices[i] = binary.BigEndian.Uint16(src[6+i*2:])
		}
		n += arrayLength * 2
	}
	return item, n, nil
}

func ParseLayout(src []byte) (Layout, int, error) {
	var item Layout
	n := 0
	{
		if L := len(src); L < 4 {
			return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.majorVersion = binary.BigEndian.Uint16(src[0:])
		item.minorVersion = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		if L := len(src); L < 6 {
			return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: 6, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[4:]))
		n += 2
		if offset != 0 { // ignore null offset
			if L := len(src); L < offset {
				return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var (
				err  error
				read int
			)
			item.scriptList, read, err = parseScriptList(src[offset:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Layout: %s", err)
			}
			offset += read

		}
	}
	{
		if L := len(src); L < 8 {
			return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: 8, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[6:]))
		n += 2
		if offset != 0 { // ignore null offset
			if L := len(src); L < offset {
				return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var (
				err  error
				read int
			)
			item.featureList, read, err = parseFeatureList(src[offset:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Layout: %s", err)
			}
			offset += read

		}
	}
	{
		if L := len(src); L < 10 {
			return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: 10, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[8:]))
		n += 2
		if offset != 0 { // ignore null offset
			if L := len(src); L < offset {
				return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var (
				err  error
				read int
			)
			item.lookupList, read, err = parseLookupList(src[offset:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Layout: %s", err)
			}
			offset += read

		}
	}
	{

		read, err := item.customParseFeatureVariations(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading Layout: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseLookup(src []byte) (Lookup, int, error) {
	var item Lookup
	n := 0
	{
		if L := len(src); L < 4 {
			return item, 0, fmt.Errorf("reading Lookup: "+"EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.lookupType = binary.BigEndian.Uint16(src[0:])
		item.lookupFlag = binary.BigEndian.Uint16(src[2:])
		n += 4
	}
	{
		if L := len(src); L < 6 {
			return item, 0, fmt.Errorf("reading Lookup: "+"EOF: expected length: 6, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*2 {
			return item, 0, fmt.Errorf("reading Lookup: "+"EOF: expected length: %d, got %d", 6+arrayLength*2, L)
		}

		item.subtableOffsets = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.subtableOffsets {
			item.subtableOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLength * 2
	}
	{
		if L := len(src); L < n+2 {
			return item, 0, fmt.Errorf("reading Lookup: "+"EOF: expected length: n + 2, got %d", L)
		}
		item.markFilteringSet = binary.BigEndian.Uint16(src[n:])
		n += 2
	}
	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseScript(src []byte) (Script, int, error) {
	var item Script
	n := 0
	{
		if L := len(src); L < 2 {
			return item, 0, fmt.Errorf("reading Script: "+"EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[0:]))
		n += 2
		if offset != 0 { // ignore null offset
			if L := len(src); L < offset {
				return item, 0, fmt.Errorf("reading Script: "+"EOF: expected length: %d, got %d", offset, L)
			}

			var (
				err  error
				read int
			)
			item.DefaultLangSys, read, err = ParseLangSys(src[offset:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Script: %s", err)
			}
			offset += read

		}
	}
	{
		if L := len(src); L < 4 {
			return item, 0, fmt.Errorf("reading Script: "+"EOF: expected length: 4, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[2:]))
		n += 2

		if L := len(src); L < 4+arrayLength*6 {
			return item, 0, fmt.Errorf("reading Script: "+"EOF: expected length: %d, got %d", 4+arrayLength*6, L)
		}

		item.langSysRecords = make([]tagOffsetRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.langSysRecords {
			item.langSysRecords[i].mustParse(src[4+i*6:])
		}
		n += arrayLength * 6
	}
	{

		read, err := item.customParseLangSys(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading Script: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func parseFeatureList(src []byte) (featureList, int, error) {
	var item featureList
	n := 0
	{
		if L := len(src); L < 2 {
			return item, 0, fmt.Errorf("reading featureList: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return item, 0, fmt.Errorf("reading featureList: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.records = make([]tagOffsetRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	{

		read, err := item.customParseFeatures(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading featureList: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func parseLookupList(src []byte) (lookupList, int, error) {
	var item lookupList
	n := 0
	{
		if L := len(src); L < 2 {
			return item, 0, fmt.Errorf("reading lookupList: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*2 {
			return item, 0, fmt.Errorf("reading lookupList: "+"EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.records = make([]Offset16, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i] = Offset16(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLength * 2
	}
	{

		read, err := item.customParseLookups(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading lookupList: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func parseScriptList(src []byte) (scriptList, int, error) {
	var item scriptList
	n := 0
	{
		if L := len(src); L < 2 {
			return item, 0, fmt.Errorf("reading scriptList: "+"EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[0:]))
		n += 2

		if L := len(src); L < 2+arrayLength*6 {
			return item, 0, fmt.Errorf("reading scriptList: "+"EOF: expected length: %d, got %d", 2+arrayLength*6, L)
		}

		item.records = make([]tagOffsetRecord, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(src[2+i*6:])
		}
		n += arrayLength * 6
	}
	{

		read, err := item.customParseScripts(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading scriptList: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func (item *tagOffsetRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.Tag = Tag(binary.BigEndian.Uint32(src[0:]))
	item.Offset = binary.BigEndian.Uint16(src[4:])
}
