package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from ot_layout_src.go. DO NOT EDIT

func (item *FeatureVariationRecord) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.conditionSetOffset = binary.BigEndian.Uint32(src[0:])
	item.featureTableSubstitutionOffset = binary.BigEndian.Uint32(src[4:])
}

func ParseFeature(src []byte) (Feature, int, error) {
	var item Feature
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading Feature: "+"EOF: expected length: 4, got %d", L)
	}
	_ = src[3] // early bound checking
	item.featureParamsOffset = binary.BigEndian.Uint16(src[0:])
	arrayLengthLookupListIndices := int(binary.BigEndian.Uint16(src[2:]))
	n += 4

	{

		if L := len(src); L < 4+arrayLengthLookupListIndices*2 {
			return item, 0, fmt.Errorf("reading Feature: "+"EOF: expected length: %d, got %d", 4+arrayLengthLookupListIndices*2, L)
		}

		item.LookupListIndices = make([]uint16, arrayLengthLookupListIndices) // allocation guarded by the previous check
		for i := range item.LookupListIndices {
			item.LookupListIndices[i] = binary.BigEndian.Uint16(src[4+i*2:])
		}
		n += arrayLengthLookupListIndices * 2
	}
	return item, n, nil
}

func ParseFeatureVariation(src []byte) (FeatureVariation, int, error) {
	var item FeatureVariation
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading FeatureVariation: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.majorVersion = binary.BigEndian.Uint16(src[0:])
	item.minorVersion = binary.BigEndian.Uint16(src[2:])
	arrayLengthFeatureVariationRecords := int(binary.BigEndian.Uint32(src[4:]))
	n += 8

	{

		if L := len(src); L < 8+arrayLengthFeatureVariationRecords*8 {
			return item, 0, fmt.Errorf("reading FeatureVariation: "+"EOF: expected length: %d, got %d", 8+arrayLengthFeatureVariationRecords*8, L)
		}

		item.featureVariationRecords = make([]FeatureVariationRecord, arrayLengthFeatureVariationRecords) // allocation guarded by the previous check
		for i := range item.featureVariationRecords {
			item.featureVariationRecords[i].mustParse(src[8+i*8:])
		}
		n += arrayLengthFeatureVariationRecords * 8
	}
	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseLangSys(src []byte) (LangSys, int, error) {
	var item LangSys
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading LangSys: "+"EOF: expected length: 6, got %d", L)
	}
	_ = src[5] // early bound checking
	item.lookupOrderOffset = binary.BigEndian.Uint16(src[0:])
	item.RequiredFeatureIndex = binary.BigEndian.Uint16(src[2:])
	arrayLengthFeatureIndices := int(binary.BigEndian.Uint16(src[4:]))
	n += 6

	{

		if L := len(src); L < 6+arrayLengthFeatureIndices*2 {
			return item, 0, fmt.Errorf("reading LangSys: "+"EOF: expected length: %d, got %d", 6+arrayLengthFeatureIndices*2, L)
		}

		item.FeatureIndices = make([]uint16, arrayLengthFeatureIndices) // allocation guarded by the previous check
		for i := range item.FeatureIndices {
			item.FeatureIndices[i] = binary.BigEndian.Uint16(src[6+i*2:])
		}
		n += arrayLengthFeatureIndices * 2
	}
	return item, n, nil
}

func ParseLayout(src []byte) (Layout, int, error) {
	var item Layout
	n := 0
	if L := len(src); L < 10 {
		return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: 10, got %d", L)
	}
	_ = src[9] // early bound checking
	item.majorVersion = binary.BigEndian.Uint16(src[0:])
	item.minorVersion = binary.BigEndian.Uint16(src[2:])
	offsetScriptList := int(binary.BigEndian.Uint16(src[4:]))
	offsetFeatureList := int(binary.BigEndian.Uint16(src[6:]))
	offsetLookupList := int(binary.BigEndian.Uint16(src[8:]))
	n += 10

	{

		if offsetScriptList != 0 { // ignore null offset
			if L := len(src); L < offsetScriptList {
				return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: %d, got %d", offsetScriptList, L)
			}

			var (
				err  error
				read int
			)
			item.scriptList, read, err = parseScriptList(src[offsetScriptList:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Layout: %s", err)
			}
			offsetScriptList += read

		}
	}
	{

		if offsetFeatureList != 0 { // ignore null offset
			if L := len(src); L < offsetFeatureList {
				return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: %d, got %d", offsetFeatureList, L)
			}

			var (
				err  error
				read int
			)
			item.featureList, read, err = parseFeatureList(src[offsetFeatureList:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Layout: %s", err)
			}
			offsetFeatureList += read

		}
	}
	{

		if offsetLookupList != 0 { // ignore null offset
			if L := len(src); L < offsetLookupList {
				return item, 0, fmt.Errorf("reading Layout: "+"EOF: expected length: %d, got %d", offsetLookupList, L)
			}

			var (
				err  error
				read int
			)
			item.lookupList, read, err = parseLookupList(src[offsetLookupList:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Layout: %s", err)
			}
			offsetLookupList += read

		}
	}
	{

		read, err := item.parseFeatureVariations(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading Layout: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseLookup(src []byte) (Lookup, int, error) {
	var item Lookup
	n := 0
	if L := len(src); L < 6 {
		return item, 0, fmt.Errorf("reading Lookup: "+"EOF: expected length: 6, got %d", L)
	}
	_ = src[5] // early bound checking
	item.lookupType = binary.BigEndian.Uint16(src[0:])
	item.lookupFlag = binary.BigEndian.Uint16(src[2:])
	arrayLengthSubtableOffsets := int(binary.BigEndian.Uint16(src[4:]))
	n += 6

	{

		if L := len(src); L < 6+arrayLengthSubtableOffsets*2 {
			return item, 0, fmt.Errorf("reading Lookup: "+"EOF: expected length: %d, got %d", 6+arrayLengthSubtableOffsets*2, L)
		}

		item.subtableOffsets = make([]Offset16, arrayLengthSubtableOffsets) // allocation guarded by the previous check
		for i := range item.subtableOffsets {
			item.subtableOffsets[i] = Offset16(binary.BigEndian.Uint16(src[6+i*2:]))
		}
		n += arrayLengthSubtableOffsets * 2
	}
	if L := len(src); L < n+2 {
		return item, 0, fmt.Errorf("reading Lookup: "+"EOF: expected length: n + 2, got %d", L)
	}
	item.markFilteringSet = binary.BigEndian.Uint16(src[n:])
	n += 2

	{

		item.rawData = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseScript(src []byte) (Script, int, error) {
	var item Script
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading Script: "+"EOF: expected length: 4, got %d", L)
	}
	_ = src[3] // early bound checking
	offsetDefaultLangSys := int(binary.BigEndian.Uint16(src[0:]))
	arrayLengthLangSysRecords := int(binary.BigEndian.Uint16(src[2:]))
	n += 4

	{

		if offsetDefaultLangSys != 0 { // ignore null offset
			if L := len(src); L < offsetDefaultLangSys {
				return item, 0, fmt.Errorf("reading Script: "+"EOF: expected length: %d, got %d", offsetDefaultLangSys, L)
			}

			var (
				err  error
				read int
			)
			item.DefaultLangSys, read, err = ParseLangSys(src[offsetDefaultLangSys:])
			if err != nil {
				return item, 0, fmt.Errorf("reading Script: %s", err)
			}
			offsetDefaultLangSys += read

		}
	}
	{

		if L := len(src); L < 4+arrayLengthLangSysRecords*6 {
			return item, 0, fmt.Errorf("reading Script: "+"EOF: expected length: %d, got %d", 4+arrayLengthLangSysRecords*6, L)
		}

		item.langSysRecords = make([]tagOffsetRecord, arrayLengthLangSysRecords) // allocation guarded by the previous check
		for i := range item.langSysRecords {
			item.langSysRecords[i].mustParse(src[4+i*6:])
		}
		n += arrayLengthLangSysRecords * 6
	}
	{

		read, err := item.parseLangSys(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading Script: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func parseFeatureList(src []byte) (featureList, int, error) {
	var item featureList
	n := 0
	if L := len(src); L < 2 {
		return item, 0, fmt.Errorf("reading featureList: "+"EOF: expected length: 2, got %d", L)
	}
	arrayLengthRecords := int(binary.BigEndian.Uint16(src[0:]))
	n += 2

	{

		if L := len(src); L < 2+arrayLengthRecords*6 {
			return item, 0, fmt.Errorf("reading featureList: "+"EOF: expected length: %d, got %d", 2+arrayLengthRecords*6, L)
		}

		item.records = make([]tagOffsetRecord, arrayLengthRecords) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(src[2+i*6:])
		}
		n += arrayLengthRecords * 6
	}
	{

		read, err := item.parseFeatures(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading featureList: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func parseLookupList(src []byte) (lookupList, int, error) {
	var item lookupList
	n := 0
	if L := len(src); L < 2 {
		return item, 0, fmt.Errorf("reading lookupList: "+"EOF: expected length: 2, got %d", L)
	}
	arrayLengthRecords := int(binary.BigEndian.Uint16(src[0:]))
	n += 2

	{

		if L := len(src); L < 2+arrayLengthRecords*2 {
			return item, 0, fmt.Errorf("reading lookupList: "+"EOF: expected length: %d, got %d", 2+arrayLengthRecords*2, L)
		}

		item.records = make([]Offset16, arrayLengthRecords) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i] = Offset16(binary.BigEndian.Uint16(src[2+i*2:]))
		}
		n += arrayLengthRecords * 2
	}
	{

		read, err := item.parseLookups(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading lookupList: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func parseScriptList(src []byte) (scriptList, int, error) {
	var item scriptList
	n := 0
	if L := len(src); L < 2 {
		return item, 0, fmt.Errorf("reading scriptList: "+"EOF: expected length: 2, got %d", L)
	}
	arrayLengthRecords := int(binary.BigEndian.Uint16(src[0:]))
	n += 2

	{

		if L := len(src); L < 2+arrayLengthRecords*6 {
			return item, 0, fmt.Errorf("reading scriptList: "+"EOF: expected length: %d, got %d", 2+arrayLengthRecords*6, L)
		}

		item.records = make([]tagOffsetRecord, arrayLengthRecords) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(src[2+i*6:])
		}
		n += arrayLengthRecords * 6
	}
	{

		read, err := item.parseScripts(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading scriptList: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func (item *tagOffsetRecord) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.Tag = Tag(binary.BigEndian.Uint32(src[0:]))
	item.Offset = binary.BigEndian.Uint16(src[4:])
}
