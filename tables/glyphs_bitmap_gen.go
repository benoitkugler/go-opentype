package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from glyphs_bitmap_src.go. DO NOT EDIT

func (item *BigGlyphMetrics) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.Height = src[0]
	item.Width = src[1]
	item.HoriBearingX = int8(src[2])
	item.HoriBearingY = int8(src[3])
	item.HoriAdvance = src[4]
	item.VertBearingX = int8(src[5])
	item.VertBearingY = int8(src[6])
	item.VertAdvance = src[7]
}

func (item *BitmapSize) mustParse(src []byte) {
	_ = src[47] // early bound checking
	item.indexSubTableArrayOffset = Offset32(binary.BigEndian.Uint32(src[0:]))
	item.indexTablesSize = binary.BigEndian.Uint32(src[4:])
	item.numberOfIndexSubTables = binary.BigEndian.Uint32(src[8:])
	item.colorRef = binary.BigEndian.Uint32(src[12:])
	item.hori.mustParse(src[16:])
	item.vert.mustParse(src[28:])
	item.startGlyphIndex = binary.BigEndian.Uint16(src[40:])
	item.endGlyphIndex = binary.BigEndian.Uint16(src[42:])
	item.ppemX = src[44]
	item.ppemY = src[45]
	item.bitDepth = src[46]
	item.flags = int8(src[47])
}

func (item *GlyphIdOffsetPair) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.GlyphID = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.SbitOffset = Offset16(binary.BigEndian.Uint16(src[2:]))
}

func (item *IndexData2) mustParse(src []byte) {
	_ = src[11] // early bound checking
	item.ImageSize = binary.BigEndian.Uint32(src[0:])
	item.BigMetrics.mustParse(src[4:])
}

func ParseCBLC(src []byte) (CBLC, int, error) {
	var item CBLC
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading CBLC: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.majorVersion = binary.BigEndian.Uint16(src[0:])
	item.minorVersion = binary.BigEndian.Uint16(src[2:])
	arrayLengthBitmapSizes := int(binary.BigEndian.Uint32(src[4:]))
	n += 8

	{

		if L := len(src); L < 8+arrayLengthBitmapSizes*48 {
			return item, 0, fmt.Errorf("reading CBLC: "+"EOF: expected length: %d, got %d", 8+arrayLengthBitmapSizes*48, L)
		}

		item.BitmapSizes = make([]BitmapSize, arrayLengthBitmapSizes) // allocation guarded by the previous check
		for i := range item.BitmapSizes {
			item.BitmapSizes[i].mustParse(src[8+i*48:])
		}
		n += arrayLengthBitmapSizes * 48
	}
	{

		read, err := item.parseIndexSubTables(src[:])
		if err != nil {
			return item, 0, fmt.Errorf("reading CBLC: %s", err)
		}
		n = read
	}
	return item, n, nil
}

func ParseIndexData1(src []byte, sbitOffsetsCount int) (IndexData1, int, error) {
	var item IndexData1
	n := 0
	{

		if L := len(src); L < sbitOffsetsCount*4 {
			return item, 0, fmt.Errorf("reading IndexData1: "+"EOF: expected length: %d, got %d", sbitOffsetsCount*4, L)
		}

		item.SbitOffsets = make([]Offset32, sbitOffsetsCount) // allocation guarded by the previous check
		for i := range item.SbitOffsets {
			item.SbitOffsets[i] = Offset32(binary.BigEndian.Uint32(src[i*4:]))
		}
		n += sbitOffsetsCount * 4
	}
	return item, n, nil
}

func ParseIndexData2(src []byte) (IndexData2, int, error) {
	var item IndexData2
	n := 0
	if L := len(src); L < 12 {
		return item, 0, fmt.Errorf("reading IndexData2: "+"EOF: expected length: 12, got %d", L)
	}
	item.mustParse(src)
	n += 12
	return item, n, nil
}

func ParseIndexData3(src []byte, sbitOffsetsCount int) (IndexData3, int, error) {
	var item IndexData3
	n := 0
	{

		if L := len(src); L < sbitOffsetsCount*2 {
			return item, 0, fmt.Errorf("reading IndexData3: "+"EOF: expected length: %d, got %d", sbitOffsetsCount*2, L)
		}

		item.SbitOffsets = make([]Offset16, sbitOffsetsCount) // allocation guarded by the previous check
		for i := range item.SbitOffsets {
			item.SbitOffsets[i] = Offset16(binary.BigEndian.Uint16(src[i*2:]))
		}
		n += sbitOffsetsCount * 2
	}
	return item, n, nil
}

func ParseIndexData4(src []byte) (IndexData4, int, error) {
	var item IndexData4
	n := 0
	if L := len(src); L < 4 {
		return item, 0, fmt.Errorf("reading IndexData4: "+"EOF: expected length: 4, got %d", L)
	}
	item.numGlyphs = binary.BigEndian.Uint32(src[0:])
	n += 4

	{
		arrayLength := int(item.numGlyphs + 1)

		if L := len(src); L < 4+arrayLength*4 {
			return item, 0, fmt.Errorf("reading IndexData4: "+"EOF: expected length: %d, got %d", 4+arrayLength*4, L)
		}

		item.GlyphArray = make([]GlyphIdOffsetPair, arrayLength) // allocation guarded by the previous check
		for i := range item.GlyphArray {
			item.GlyphArray[i].mustParse(src[4+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func ParseIndexData5(src []byte) (IndexData5, int, error) {
	var item IndexData5
	n := 0
	if L := len(src); L < 14 {
		return item, 0, fmt.Errorf("reading IndexData5: "+"EOF: expected length: 14, got %d", L)
	}
	_ = src[13] // early bound checking
	item.ImageSize = binary.BigEndian.Uint32(src[0:])
	item.BigMetrics.mustParse(src[4:])
	arrayLengthGlyphIdArray := int(binary.BigEndian.Uint16(src[12:]))
	n += 14

	{

		if L := len(src); L < 14+arrayLengthGlyphIdArray*2 {
			return item, 0, fmt.Errorf("reading IndexData5: "+"EOF: expected length: %d, got %d", 14+arrayLengthGlyphIdArray*2, L)
		}

		item.GlyphIdArray = make([]GlyphID, arrayLengthGlyphIdArray) // allocation guarded by the previous check
		for i := range item.GlyphIdArray {
			item.GlyphIdArray[i] = GlyphID(binary.BigEndian.Uint16(src[14+i*2:]))
		}
		n += arrayLengthGlyphIdArray * 2
	}
	return item, n, nil
}

func ParseIndexSubHeader(src []byte, sbitOffsetsCount int) (IndexSubHeader, int, error) {
	var item IndexSubHeader
	n := 0
	if L := len(src); L < 8 {
		return item, 0, fmt.Errorf("reading IndexSubHeader: "+"EOF: expected length: 8, got %d", L)
	}
	_ = src[7] // early bound checking
	item.indexFormat = indexVersion(binary.BigEndian.Uint16(src[0:]))
	item.imageFormat = binary.BigEndian.Uint16(src[2:])
	item.imageDataOffset = Offset32(binary.BigEndian.Uint32(src[4:]))
	n += 8

	{
		var (
			read int
			err  error
		)
		switch item.indexFormat {
		case indexVersion1:
			item.IndexData, read, err = ParseIndexData1(src[8:], sbitOffsetsCount)
		case indexVersion2:
			item.IndexData, read, err = ParseIndexData2(src[8:])
		case indexVersion3:
			item.IndexData, read, err = ParseIndexData3(src[8:], sbitOffsetsCount)
		case indexVersion4:
			item.IndexData, read, err = ParseIndexData4(src[8:])
		case indexVersion5:
			item.IndexData, read, err = ParseIndexData5(src[8:])
		default:
			err = fmt.Errorf("unsupported IndexDataVersion %d", item.indexFormat)
		}
		if err != nil {
			return item, 0, fmt.Errorf("reading IndexSubHeader: %s", err)
		}
		n += read
	}
	return item, n, nil
}

func ParseIndexSubTableArray(src []byte, subtablesCount int) (IndexSubTableArray, int, error) {
	var item IndexSubTableArray
	n := 0
	{

		if L := len(src); L < subtablesCount*8 {
			return item, 0, fmt.Errorf("reading IndexSubTableArray: "+"EOF: expected length: %d, got %d", subtablesCount*8, L)
		}

		item.Subtables = make([]indexSubTableHeader, subtablesCount) // allocation guarded by the previous check
		for i := range item.Subtables {
			item.Subtables[i].mustParse(src[i*8:])
		}
		n += subtablesCount * 8
	}
	return item, n, nil
}

func (item *SbitLineMetrics) mustParse(src []byte) {
	_ = src[11] // early bound checking
	item.ascender = int8(src[0])
	item.descender = int8(src[1])
	item.widthMax = src[2]
	item.caretSlopeNumerator = int8(src[3])
	item.caretSlopeDenominator = int8(src[4])
	item.caretOffset = int8(src[5])
	item.minOriginSB = int8(src[6])
	item.minAdvanceSB = int8(src[7])
	item.maxBeforeBL = int8(src[8])
	item.minAfterBL = int8(src[9])
	item.pad1 = int8(src[10])
	item.pad2 = int8(src[11])
}

func (item *indexSubTableHeader) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.FirstGlyph = GlyphID(binary.BigEndian.Uint16(src[0:]))
	item.LastGlyph = GlyphID(binary.BigEndian.Uint16(src[2:]))
	item.additionalOffsetToIndexSubtable = Offset32(binary.BigEndian.Uint32(src[4:]))
}
