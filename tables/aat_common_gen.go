package tables

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from aat_common.go. DO NOT EDIT

func (item *aatExtendedLookupTable) mustParse(src []byte) {
	_ = src[1] // early bound checking
	item.version = binary.BigEndian.Uint16(src[0:])
}

func parseAatExtendedLookupTable(src []byte) (aatExtendedLookupTable, int, error) {
	var item aatExtendedLookupTable
	n := 0
	if L := len(src); L < 2 {
		return aatExtendedLookupTable{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
	}

	item.mustParse(src)
	n += 2
	return item, n, nil
}

func parseAatExtendedStateTable(src []byte) (aatExtendedStateTable, int, error) {
	var item aatExtendedStateTable
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 16 {
			return aatExtendedStateTable{}, 0, fmt.Errorf("EOF: expected length: 16, got %d", L)
		}

		_ = subSlice[15] // early bound checking
		item.stateSize = binary.BigEndian.Uint32(subSlice[0:])
		item.classTable = binary.BigEndian.Uint32(subSlice[4:])
		item.stateArray = binary.BigEndian.Uint32(subSlice[8:])
		item.entryTable = binary.BigEndian.Uint32(subSlice[12:])
		n += 16

	}
	item.data = src[n:]
	n = len(src)

	return item, n, nil
}

func parseAatLookup(src []byte, valuesLength int) (aatLookup, int, error) {
	var item aatLookup
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookup{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}

		_ = subSlice[1] // early bound checking
		item.version = aatLookupVersion(binary.BigEndian.Uint16(subSlice[0:]))
		n += 2

	}
	{
		var read int
		var err error
		switch item.version {
		case aatLookupTableVersion0:
			item.table, read, err = parseAatLookupTable0(src[n:], valuesLength)
		case aatLookupTableVersion10:
			item.table, read, err = parseAatLookupTable10(src[n:])
		case aatLookupTableVersion2:
			item.table, read, err = parseAatLookupTable2(src[n:])
		case aatLookupTableVersion4:
			item.table, read, err = parseAatLookupTable4(src[n:])
		case aatLookupTableVersion6:
			item.table, read, err = parseAatLookupTable6(src[n:])
		case aatLookupTableVersion8:
			item.table, read, err = parseAatLookupTable8(src[n:])
		default:
			err = fmt.Errorf("unsupported aatLookupTableVersion %d", item.version)
		}
		if err != nil {
			return aatLookup{}, 0, err
		}
		n += read
	}
	return item, n, nil
}

func parseAatLookupExt(src []byte, valuesLength int) (aatLookupExt, int, error) {
	var item aatLookupExt
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookupExt{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}

		_ = subSlice[1] // early bound checking
		item.version = aatLookupVersion(binary.BigEndian.Uint16(subSlice[0:]))
		n += 2

	}
	{
		var read int
		var err error
		switch item.version {
		case aatLookupTableVersion0:
			item.table, read, err = parseAatLookupTableExt0(src[n:], valuesLength)
		case aatLookupTableVersion10:
			item.table, read, err = parseAatLookupTableExt10(src[n:])
		case aatLookupTableVersion2:
			item.table, read, err = parseAatLookupTableExt2(src[n:])
		case aatLookupTableVersion4:
			item.table, read, err = parseAatLookupTableExt4(src[n:])
		case aatLookupTableVersion6:
			item.table, read, err = parseAatLookupTableExt6(src[n:])
		case aatLookupTableVersion8:
			item.table, read, err = parseAatLookupTableExt8(src[n:])
		default:
			err = fmt.Errorf("unsupported aatLookupTableExtVersion %d", item.version)
		}
		if err != nil {
			return aatLookupExt{}, 0, err
		}
		n += read
	}
	return item, n, nil
}

func parseAatLookupTable0(src []byte, valuesLength int) (aatLookupTable0, int, error) {
	var item aatLookupTable0
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < +valuesLength*2 {
			return aatLookupTable0{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +valuesLength*2, L)
		}

		item.values = make([]uint16, valuesLength) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(subSlice[+i*2:])
		}

		n += valuesLength * 2
	}
	return item, n, nil
}

func parseAatLookupTable10(src []byte) (aatLookupTable10, int, error) {
	var item aatLookupTable10
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 4 {
			return aatLookupTable10{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
		}

		_ = subSlice[3] // early bound checking
		item.unitSize = binary.BigEndian.Uint16(subSlice[0:])
		item.firstGlyph = glyphID(binary.BigEndian.Uint16(subSlice[2:]))
		n += 4

	}
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookupTable10{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2, L)
		}

		arrayLength := int(binary.BigEndian.Uint16(subSlice[:]))
		if L := len(subSlice); L < 2+arrayLength*2 {
			return aatLookupTable10{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.values = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(subSlice[2+i*2:])
		}

		n += 2 + arrayLength*2
	}
	return item, n, nil
}

func parseAatLookupTable2(src []byte) (aatLookupTable2, int, error) {
	var item aatLookupTable2
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTable2{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*6 {
			return aatLookupTable2{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*6, L)
		}

		item.records = make([]lookupRecord2, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*6:])
		}

		n += arrayLength * 6
	}
	return item, n, nil
}

func parseAatLookupTable4(src []byte) (aatLookupTable4, int, error) {
	var item aatLookupTable4
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTable4{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*6 {
			return aatLookupTable4{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*6, L)
		}

		item.records = make([]loopkupRecord4, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*6:])
		}

		n += arrayLength * 6
	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}

func parseAatLookupTable6(src []byte) (aatLookupTable6, int, error) {
	var item aatLookupTable6
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTable6{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*4 {
			return aatLookupTable6{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*4, L)
		}

		item.records = make([]loopkupRecord6, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*4:])
		}

		n += arrayLength * 4
	}
	return item, n, nil
}

func parseAatLookupTable8(src []byte) (aatLookupTable8, int, error) {
	var item aatLookupTable8
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookupTable8{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}

		_ = subSlice[1] // early bound checking
		item.firstGlyph = glyphID(binary.BigEndian.Uint16(subSlice[0:]))
		n += 2

	}
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookupTable8{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2, L)
		}

		arrayLength := int(binary.BigEndian.Uint16(subSlice[:]))
		if L := len(subSlice); L < 2+arrayLength*2 {
			return aatLookupTable8{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.values = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(subSlice[2+i*2:])
		}

		n += 2 + arrayLength*2
	}
	return item, n, nil
}

func parseAatLookupTableExt0(src []byte, valuesLength int) (aatLookupTableExt0, int, error) {
	var item aatLookupTableExt0
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < +valuesLength*4 {
			return aatLookupTableExt0{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +valuesLength*4, L)
		}

		item.values = make([]uint32, valuesLength) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint32(subSlice[+i*4:])
		}

		n += valuesLength * 4
	}
	return item, n, nil
}

func parseAatLookupTableExt10(src []byte) (aatLookupTableExt10, int, error) {
	var item aatLookupTableExt10
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 4 {
			return aatLookupTableExt10{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
		}

		_ = subSlice[3] // early bound checking
		item.unitSize = binary.BigEndian.Uint16(subSlice[0:])
		item.firstGlyph = glyphID(binary.BigEndian.Uint16(subSlice[2:]))
		n += 4

	}
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookupTableExt10{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2, L)
		}

		arrayLength := int(binary.BigEndian.Uint16(subSlice[:]))
		if L := len(subSlice); L < 2+arrayLength*4 {
			return aatLookupTableExt10{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength*4, L)
		}

		item.values = make([]uint32, arrayLength) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint32(subSlice[2+i*4:])
		}

		n += 2 + arrayLength*4
	}
	return item, n, nil
}

func parseAatLookupTableExt2(src []byte) (aatLookupTableExt2, int, error) {
	var item aatLookupTableExt2
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTableExt2{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*8 {
			return aatLookupTableExt2{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*8, L)
		}

		item.records = make([]lookupRecordExt2, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*8:])
		}

		n += arrayLength * 8
	}
	return item, n, nil
}

func parseAatLookupTableExt4(src []byte) (aatLookupTableExt4, int, error) {
	var item aatLookupTableExt4
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTableExt4{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*6 {
			return aatLookupTableExt4{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*6, L)
		}

		item.records = make([]loopkupRecord4, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*6:])
		}

		n += arrayLength * 6
	}
	item.rawData = src[n:]
	n = len(src)

	return item, n, nil
}

func parseAatLookupTableExt6(src []byte) (aatLookupTableExt6, int, error) {
	var item aatLookupTableExt6
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 10 {
			return aatLookupTableExt6{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
		}

		_ = subSlice[9] // early bound checking
		item.binSearchHeader.mustParse(subSlice[0:])
		n += 10

	}
	{
		subSlice := src[n:]
		arrayLength := int(item.nUnits)
		if L := len(subSlice); L < +arrayLength*6 {
			return aatLookupTableExt6{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", +arrayLength*6, L)
		}

		item.records = make([]loopkupRecordExt6, arrayLength) // allocation guarded by the previous check
		for i := range item.records {
			item.records[i].mustParse(subSlice[+i*6:])
		}

		n += arrayLength * 6
	}
	return item, n, nil
}

func parseAatLookupTableExt8(src []byte) (aatLookupTableExt8, int, error) {
	var item aatLookupTableExt8
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookupTableExt8{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}

		_ = subSlice[1] // early bound checking
		item.firstGlyph = glyphID(binary.BigEndian.Uint16(subSlice[0:]))
		n += 2

	}
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return aatLookupTableExt8{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2, L)
		}

		arrayLength := int(binary.BigEndian.Uint16(subSlice[:]))
		if L := len(subSlice); L < 2+arrayLength*2 {
			return aatLookupTableExt8{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 2+arrayLength*2, L)
		}

		item.values = make([]uint16, arrayLength) // allocation guarded by the previous check
		for i := range item.values {
			item.values[i] = binary.BigEndian.Uint16(subSlice[2+i*2:])
		}

		n += 2 + arrayLength*2
	}
	return item, n, nil
}

func (item *aatStateEntry0) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.newState = binary.BigEndian.Uint16(src[0:])
	item.flags = binary.BigEndian.Uint16(src[2:])
}

func parseAatStateEntry0(src []byte) (aatStateEntry0, int, error) {
	var item aatStateEntry0
	n := 0
	if L := len(src); L < 4 {
		return aatStateEntry0{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
	}

	item.mustParse(src)
	n += 4
	return item, n, nil
}

func (item *aatStateEntry2) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.newState = binary.BigEndian.Uint16(src[0:])
	item.flags = binary.BigEndian.Uint16(src[2:])
	for i := range item.data {
		item.data[i] = src[4+i]
	}
}

func parseAatStateEntry2(src []byte) (aatStateEntry2, int, error) {
	var item aatStateEntry2
	n := 0
	if L := len(src); L < 6 {
		return aatStateEntry2{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
	}

	item.mustParse(src)
	n += 6
	return item, n, nil
}

func (item *aatStateEntry4) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.newState = binary.BigEndian.Uint16(src[0:])
	item.flags = binary.BigEndian.Uint16(src[2:])
	for i := range item.data {
		item.data[i] = src[4+i]
	}
}

func parseAatStateEntry4(src []byte) (aatStateEntry4, int, error) {
	var item aatStateEntry4
	n := 0
	if L := len(src); L < 8 {
		return aatStateEntry4{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
	}

	item.mustParse(src)
	n += 8
	return item, n, nil
}

func parseAatStateTable(src []byte) (aatStateTable, int, error) {
	var item aatStateTable
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 8 {
			return aatStateTable{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
		}

		_ = subSlice[7] // early bound checking
		item.stateSize = binary.BigEndian.Uint16(subSlice[0:])
		item.classTable = binary.BigEndian.Uint16(subSlice[2:])
		item.stateArray = binary.BigEndian.Uint16(subSlice[4:])
		item.entryTable = binary.BigEndian.Uint16(subSlice[6:])
		n += 8

	}
	item.data = src[n:]
	n = len(src)

	return item, n, nil
}

func (item *binSearchHeader) mustParse(src []byte) {
	_ = src[9] // early bound checking
	item.unitSize = binary.BigEndian.Uint16(src[0:])
	item.nUnits = binary.BigEndian.Uint16(src[2:])
	item.searchRange = binary.BigEndian.Uint16(src[4:])
	item.entrySelector = binary.BigEndian.Uint16(src[6:])
	item.rangeShift = binary.BigEndian.Uint16(src[8:])
}

func parseBinSearchHeader(src []byte) (binSearchHeader, int, error) {
	var item binSearchHeader
	n := 0
	if L := len(src); L < 10 {
		return binSearchHeader{}, 0, fmt.Errorf("EOF: expected length: 10, got %d", L)
	}

	item.mustParse(src)
	n += 10
	return item, n, nil
}

func (item *lookupRecord2) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.lastGlyph = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.firstGlyph = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.value = binary.BigEndian.Uint16(src[4:])
}

func parseLookupRecord2(src []byte) (lookupRecord2, int, error) {
	var item lookupRecord2
	n := 0
	if L := len(src); L < 6 {
		return lookupRecord2{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
	}

	item.mustParse(src)
	n += 6
	return item, n, nil
}

func (item *lookupRecordExt2) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.lastGlyph = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.firstGlyph = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.value = binary.BigEndian.Uint32(src[4:])
}

func parseLookupRecordExt2(src []byte) (lookupRecordExt2, int, error) {
	var item lookupRecordExt2
	n := 0
	if L := len(src); L < 8 {
		return lookupRecordExt2{}, 0, fmt.Errorf("EOF: expected length: 8, got %d", L)
	}

	item.mustParse(src)
	n += 8
	return item, n, nil
}

func (item *loopkupRecord4) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.lastGlyph = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.firstGlyph = glyphID(binary.BigEndian.Uint16(src[2:]))
	item.offsetToValues = binary.BigEndian.Uint16(src[4:])
}

func parseLoopkupRecord4(src []byte) (loopkupRecord4, int, error) {
	var item loopkupRecord4
	n := 0
	if L := len(src); L < 6 {
		return loopkupRecord4{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
	}

	item.mustParse(src)
	n += 6
	return item, n, nil
}

func (item *loopkupRecord6) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.glyph = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.value = binary.BigEndian.Uint16(src[2:])
}

func parseLoopkupRecord6(src []byte) (loopkupRecord6, int, error) {
	var item loopkupRecord6
	n := 0
	if L := len(src); L < 4 {
		return loopkupRecord6{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
	}

	item.mustParse(src)
	n += 4
	return item, n, nil
}

func (item *loopkupRecordExt6) mustParse(src []byte) {
	_ = src[5] // early bound checking
	item.glyph = glyphID(binary.BigEndian.Uint16(src[0:]))
	item.value = binary.BigEndian.Uint32(src[2:])
}

func parseLoopkupRecordExt6(src []byte) (loopkupRecordExt6, int, error) {
	var item loopkupRecordExt6
	n := 0
	if L := len(src); L < 6 {
		return loopkupRecordExt6{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
	}

	item.mustParse(src)
	n += 6
	return item, n, nil
}
